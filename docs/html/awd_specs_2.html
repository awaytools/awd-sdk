<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.8"/>
<title>cpp-libawd: Part II: File format specification</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="Logo_AwayTools_300x300.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">cpp-libawd
   </div>
   <div id="projectbrief">cpp-library to convert and prepare AWD-data</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.8 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('awd_specs_2.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Part II: File format specification </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>AWD 3.0 Specification in markdown format.</p>
<h1><a class="anchor" id="awd_pt2_1"></a>
Top-level structure of an AWD document</h1>
<p>Top-level structure of an <a class="el" href="namespace_a_w_d.html" title="The namespace used for the complete libawd. ">AWD</a> document</p>
<p>The <a class="el" href="namespace_a_w_d.html" title="The namespace used for the complete libawd. ">AWD</a> document always begins with an uncompressed file header with meta-data, which is followed by an optionally compressed file body, containing the actual data.</p>
<table class="doxtable">
<tr>
<th>Offset </th><th>Size </th><th>Type </th><th>Description  </th></tr>
<tr>
<td>0 </td><td>11 </td><td>File header </td><td>See section File header </td></tr>
<tr>
<td>11 </td><td>Variable</td><td>List of blocks </td><td>See section File body </td></tr>
</table>
<p>Table 1: <a class="el" href="namespace_a_w_d.html" title="The namespace used for the complete libawd. ">AWD</a> top-level structure</p>
<h2><a class="anchor" id="awd_pt2_file_header"></a>
File header</h2>
<p>The header defines which version of the <a class="el" href="namespace_a_w_d.html" title="The namespace used for the complete libawd. ">AWD</a> format specification a file conforms to.</p>
<p>It also defines the algorithm used to compress the data body, if any, and other configuration flags.</p>
<p>Using a “Magic string”, it identifies itself as an <a class="el" href="namespace_a_w_d.html" title="The namespace used for the complete libawd. ">AWD</a> file.</p>
<p>In cpp-libAWD, the file-header is encoded inside the function <a class="el" href="class_a_w_d_1_1_f_i_l_e_s_1_1_a_w_d_file.html#aafa4732e78571d19d010f62c32240b9c" title="Export the AWDFile to disc. This function will manage the writing of the individual blocks...">AWD::FILES::AWDFile::write_to_disc()</a> and parsed inside the function <a class="el" href="class_a_w_d_1_1_f_i_l_e_s_1_1_a_w_d_file.html#a86c54a265573e1e9094335066de537d1" title="Read the AWDFile from disc. ">AWD::FILES::AWDFile::read_from_disc()</a></p>
<table class="doxtable">
<tr>
<th>Offset </th><th>Size </th><th>Type </th><th>Description  </th></tr>
<tr>
<td>0 </td><td>3 </td><td>awd_pt2_6_4_1 </td><td>Magic string, “AWD” </td></tr>
<tr>
<td>3 </td><td>1 </td><td><a class="el" href="namespace_a_w_d_1_1_t_y_p_e_s.html#a9b0ef4ec4c165261b02c26c50905fb44">AWD::TYPES::UINT8</a> </td><td>Version number (major version.) </td></tr>
<tr>
<td>4 </td><td>1 </td><td><a class="el" href="namespace_a_w_d_1_1_t_y_p_e_s.html#a9b0ef4ec4c165261b02c26c50905fb44">AWD::TYPES::UINT8</a> </td><td>Revision number (minor version.) </td></tr>
<tr>
<td>5 </td><td>2 </td><td><a class="el" href="namespace_a_w_d_1_1_t_y_p_e_s.html#a075134ec2b704611a32263526f53a60e">AWD::TYPES::UINT16</a> </td><td>Flags (two-byte bitflag, see separate table.) </td></tr>
<tr>
<td>7 </td><td>1 </td><td><a class="el" href="namespace_a_w_d_1_1_t_y_p_e_s.html#a9b0ef4ec4c165261b02c26c50905fb44">AWD::TYPES::UINT8</a> </td><td><a class="el" href="namespace_a_w_d_1_1_s_e_t_t_i_n_g_s.html#a49fae1a3555637fb712c1cf03b73f1b0" title="Types of compression. ">AWD::SETTINGS::compression</a> </td></tr>
<tr>
<td>8 </td><td>4 </td><td><a class="el" href="namespace_a_w_d_1_1_t_y_p_e_s.html#a0633e60becfa73b1f2e7681b000314c0">AWD::TYPES::UINT32</a> </td><td>Compressed body length in bytes. Used for integrity check. Ignored if streaming. </td></tr>
</table>
<p>Table 2: <a class="el" href="namespace_a_w_d.html" title="The namespace used for the complete libawd. ">AWD</a> header structure</p>
<h3><a class="anchor" id="awd_pt2_file_header_1"></a>
Flags</h3>
<p>The flags field is a two-byte bitflag field where each bit is a boolean (0=false, 1=true) that defines a configuration parameter for the entire file. The meaning of each bit is defined and described in the table below.</p>
<p>In cpp-libAWD, the bitflag is converted to or from settings inside the functions <a class="el" href="class_a_w_d_1_1_s_e_t_t_i_n_g_s_1_1_settings.html#aa3bd0282644e09586e939b525a52a67f">AWD::SETTINGS::Settings::get_file_header_flag()</a> and <a class="el" href="class_a_w_d_1_1_s_e_t_t_i_n_g_s_1_1_settings.html#af85e82d12ff6cb8a03149c69ed9d728f">AWD::SETTINGS::Settings::set_file_header_flag()</a></p>
<table class="doxtable">
<tr>
<th>Bit </th><th>Value </th><th>Name </th><th>Description  </th></tr>
<tr>
<td>00 </td><td>0x0001 </td><td>Streaming </td><td>Defines whether this file should be treated as a streaming file. If this bit is set, it means that the file is streaming and that more blocks can be expected even after the file appears to end. </td></tr>
<tr>
<td>01 </td><td></td><td>Global-Matrix-Storage-Precision </td><td>Only used if Bit 04 is not set (is false) </td></tr>
<tr>
<td>02 </td><td></td><td>Global-Geometry-StoragePrecision </td><td>Only used if Bit 04 is not set (is false) </td></tr>
<tr>
<td>03 </td><td></td><td>Global-Properties-StoragePrecision </td><td>Only used if Bit 04 is not set (is false) </td></tr>
<tr>
<td>04 </td><td></td><td>Use Storage-Precision per Block </td><td>Decides if Storage-Precision is defined per file,or per block </td></tr>
<tr>
<td>05-15 </td><td></td><td>Unused </td><td>Unused in this version of the format. </td></tr>
</table>
<p>Table 3: <a class="el" href="namespace_a_w_d.html" title="The namespace used for the complete libawd. ">AWD</a> header flag bits</p>
<h2><a class="anchor" id="awd_pt2_1_2"></a>
File body</h2>
<p>The file body data is a sequence of any number of data blocks, where each data block has the same toplevel format, with fields defining block type and size (See the section called "The data block concept" for details). The file body in it's entirety can optionally be compressed using one of the supported compression algorithms. Body blocks can also be added to an existing <a class="el" href="namespace_a_w_d.html" title="The namespace used for the complete libawd. ">AWD</a> document over time, via a mutable media like a network socket. This is referred to as streaming.</p>
<h1><a class="anchor" id="awd_pt2_2"></a>
Streaming AWD</h1>
<p>The <a class="el" href="namespace_a_w_d.html" title="The namespace used for the complete libawd. ">AWD</a> file format has been designed with the possibility of streaming and progressive loading in mind. Block references are required to always point backwards (to a previously declared block) which means that a parser can be certain when encountering a reference that it is not being made to a currently unknown block even though the entire file has not yet been downloaded.</p>
<p>To alert a parser that a document is streaming (and hence that the parser should continue reading data when available until the stream is closed by the environment) the “streaming” flag bit must be set in the flags field in the header.</p>
<p>Streaming <a class="el" href="namespace_a_w_d.html" title="The namespace used for the complete libawd. ">AWD</a> files do not support compression since parsing needs to be possible even before the entire document has finished loading (if it ever does.). Future versions of the format may support per-block compression.</p>
<h1><a class="anchor" id="awd_pt2_3"></a>
Compression</h1>
<p>The body part of an <a class="el" href="namespace_a_w_d.html" title="The namespace used for the complete libawd. ">AWD</a> file can optionally be compressed using one of the two supported compression algorithms, ZLIB (deflate) and LZMA. Which algorithm is used is defined by the compression type field in the document header. If a parser does not recognize the algorithm defined in the compression type header field, the file can not be read by that parser, which should exit with an error status.</p>
<h2><a class="anchor" id="awd_pt2_3_1"></a>
ZLIB/Deflate compression</h2>
<p>The ZLIB/Deflate compression algorithm is used by the very popular ZIP and GZIP compression file formats and provides a fairly efficient compression at low decompression performance costs. Deflate compression is natively supported by many environments, including Flash Player. This means that in many cases (one of which is indeed the Flash Player) ZLIB compression is an excellent trade-off between file size and decompression speed. In Flash Player particularly, native decompression of ZLIB/Deflate can be several orders of magnitude faster than decoding other formats using implementations in ActionScript 3. In a ZLIB compressed <a class="el" href="namespace_a_w_d.html" title="The namespace used for the complete libawd. ">AWD</a> file, the body is the exact output from ZLIB including heading and trailing metadata (checksum), which means it can be handed straight to a ZLIB decoding (inflation) machine.</p>
<p>there has been some confusion about this compression-type, because in previous drafts for AWD-specs it was named ZLIB/Deflate. There has been no offizial encoder that was comporessing using the Deflate-algorithm. Compression-type 1 is ZLIB. A new compression-type (Deflate = 3) has been added to AWD3.0</p>
<h2><a class="anchor" id="awd_pt2_3_2"></a>
LZMA compression</h2>
<p>LZMA is an extremely efficient compression algorithm and is part of the popular Windows 7zip compression utility. However, because native implementations are rare, and none exists for Flash Player, decompression often means more work and is often slower than when using ZLIB. The LZMA compression is very configurable, and hence requires some meta-data to be stored for the compressed body data to be correctly decompressed. The first nine bytes of the body data in an LZMAcompressed <a class="el" href="namespace_a_w_d.html" title="The namespace used for the complete libawd. ">AWD</a> file define the size of the decompressed body as an unsigned 32-bit integer, followed by the LZMA properties encoded as per the LZMA standard. The below table describes the body structure of an LZMA-compressed <a class="el" href="namespace_a_w_d.html" title="The namespace used for the complete libawd. ">AWD</a> file.</p>
<table class="doxtable">
<tr>
<th>Offset </th><th>Size </th><th>Type </th><th>Description  </th></tr>
<tr>
<td>0 </td><td>4 </td><td><a class="el" href="namespace_a_w_d_1_1_t_y_p_e_s.html#a0633e60becfa73b1f2e7681b000314c0">AWD::TYPES::UINT32</a> </td><td>Length of decompressed body. </td></tr>
<tr>
<td>4 </td><td>5 </td><td>ByteArray </td><td>LZMA properties encoded as defined in the LZMA SDK. </td></tr>
<tr>
<td>9 </td><td>Variable </td><td>ByteArray </td><td>Compressed body data. </td></tr>
</table>
<p>Table 4: Structure of an LZMA-compressed <a class="el" href="namespace_a_w_d.html" title="The namespace used for the complete libawd. ">AWD</a> body</p>
<p>This structure allows for easy decompression using the LZMA SDK LzmaDecode() function, without the need of dynamic buffer allocation and chunk-for-chunk decompression of the stream.</p>
<h1><a class="anchor" id="awd_pt2_4"></a>
Field types and special values</h1>
<p>In this specification are recurring references to a number of both POD and complex (aggregate) data types.</p>
<p>This section details the format of these data types and how they are parsed.</p>
<h2><a class="anchor" id="awd_pt2_4_1"></a>
Storage-Precision</h2>
<p>Storage precision is defined in the FileHeader-BitFlags (flag01,flag02, flag03, flag04) and in the BlockHeader-BitFlags (flag00, flag01, flag02)</p>
<p>Flag04 of the FileHeader-BitFlags defines if the 3 Storage-Precision-Parameter should be used global for a file or if they should be overwritten by the BlockHeader-BitFlags. The Storage-Preciosion per File is not really needed anymore, since the BlockHeader-BitFlag containing the Storage-Precision per Block is is stored, parsed and reserved for this values anyway. It only exists for legacy reasons (It was allready defined in AWD2.0). But since the StoragePrecision has never been actually implemented in the Parsers/Encoder before, we really dont need it anymore.</p>
<p>Storage-Precision is defined for 4 different typ of AWD-Data</p>
<h3><a class="anchor" id="awd_pt2_4_1_1"></a>
MatrixSP</h3>
<p>The storage-prevision used to define if Numbers that are used for scene-tranforms, should be written to file with AWD::TYPES::FLOAT32 or AWD::TYPES::FLOAT32</p>
<h3><a class="anchor" id="awd_pt2_4_1_2"></a>
GeomSP</h3>
<p>The storage-prevision used to define if Numbers that are used for geometry-streams, should be written to file with AWD::TYPES::FLOAT32 or AWD::TYPES::FLOAT32</p>
<h3><a class="anchor" id="awd_pt2_4_1_3"></a>
PropsSP</h3>
<p>The storage-prevision used to define if Numbers that are used for block-properties, should be written to file with AWD::TYPES::FLOAT32 or AWD::TYPES::FLOAT32</p>
<h3><a class="anchor" id="awd_pt2_4_1_4"></a>
AttrSP</h3>
<p>The storage-prevision used to define if Numbers that are used for user-attributes, should be written to file with AWD::TYPES::FLOAT32 or AWD::TYPES::FLOAT32</p>
<table class="doxtable">
<tr>
<th>FileHeader </th><th>BlockHeader </th><th>used for </th><th>Name in this doc </th><th>value if true </th><th>value if false  </th></tr>
<tr>
<td>01 </td><td>0 </td><td>used for all Scene-tranforms </td><td>awd_pt2_5_1 </td><td>float64 </td><td>float32 </td></tr>
<tr>
<td>02 </td><td>1 </td><td>used for all Numbers stored in streams </td><td>awd_pt2_5_2 </td><td>float64 </td><td>float32 </td></tr>
<tr>
<td>03 </td><td>2 </td><td>used for Properties </td><td>awd_pt2_5_3 </td><td>float64 </td><td>float32 </td></tr>
<tr>
<td>&ndash; </td><td>&ndash; </td><td>Storage-Precision for UserAttributes (Numbers) stored with each Attribute </td><td>awd_pt2_5_4 </td><td>float64 </td><td>float32 </td></tr>
</table>
<h2><a class="anchor" id="awd_pt2_4_2"></a>
Field type identification</h2>
<p>In contexts where types can vary (e.g. user attributes, see below) the data type is identified by an 8bit integer ID. This 8bit field, when referred to in structure tables, is simply called type.</p>
<table class="doxtable">
<tr>
<th>ID </th><th>Type </th><th>Category  </th></tr>
<tr>
<td>1 </td><td>int8 </td><td>Numeric </td></tr>
<tr>
<td>2 </td><td>int16 </td><td>Numeric </td></tr>
<tr>
<td>3 </td><td>int32 </td><td>Numeric </td></tr>
<tr>
<td>4 </td><td>uint8 </td><td>Numeric </td></tr>
<tr>
<td>5 </td><td>uint16 </td><td>Numeric </td></tr>
<tr>
<td>6 </td><td><a class="el" href="namespace_a_w_d_1_1_t_y_p_e_s.html#a0633e60becfa73b1f2e7681b000314c0">AWD::TYPES::UINT32</a> </td><td>Numeric </td></tr>
<tr>
<td>11 </td><td>float32 </td><td>Numeric </td></tr>
<tr>
<td>12 </td><td>float64 </td><td>Numeric </td></tr>
<tr>
<td>21 </td><td>bool </td><td>Derived numeric </td></tr>
<tr>
<td>22 </td><td>color </td><td>Derived numeric </td></tr>
<tr>
<td>23 </td><td><a class="el" href="namespace_a_w_d_1_1_t_y_p_e_s.html#a67050e0d5b2ec92455d9df844eefa24b">AWD::TYPES::BADDR</a> </td><td>Derived numeric </td></tr>
<tr>
<td>31 </td><td>ConstString </td><td>Array types </td></tr>
<tr>
<td>32 </td><td>ByteArray </td><td>Array types </td></tr>
<tr>
<td>41 </td><td>Vector2x1 </td><td>Math types </td></tr>
<tr>
<td>42 </td><td>Vector3x1 </td><td>Math types </td></tr>
<tr>
<td>43 </td><td>Vector4x1 </td><td>Math types </td></tr>
<tr>
<td>51 </td><td>Matrix3x2 </td><td>Math types </td></tr>
<tr>
<td>52 </td><td>Matrix3x3 </td><td>Math types </td></tr>
<tr>
<td>53 </td><td>Matrix4x3 </td><td>Math types </td></tr>
<tr>
<td>54 </td><td>Matrix4x4 </td><td>Math types </td></tr>
</table>
<p>Table 5: Field data type identifiers.</p>
<h2><a class="anchor" id="awd_pt2_4_3"></a>
Numbers</h2>
<h3><a class="anchor" id="awd_pt2_4_3_1"></a>
Endianness</h3>
<p>All numeric values in <a class="el" href="namespace_a_w_d.html" title="The namespace used for the complete libawd. ">AWD</a> are little-endian. Numeric values should never be encoded as big-endian in <a class="el" href="namespace_a_w_d.html" title="The namespace used for the complete libawd. ">AWD</a>. This means that to read a multi-byte numeric field the parser has to wait until the entire field has been loaded (since the MSB is the last one.) However, it also has performance gains on most modern platforms which are natively little-endian, and thus able to read entire streams of little-endian numeric data in a single operation. On these systems the same streams can then be sent of to the GPU without any marshaling, which constitutes a big optimizations particularly in high-level languages like ActionScript (Flash) and JavaScript (WebGL).</p>
<h3><a class="anchor" id="awd_pt2_4_3_2"></a>
Integers</h3>
<p>All fields that contain integers are defined as either int or uint (for unsigned integers) regardless of the size of their C representation. They are never referred to as "long", "short", "word" or any of the typical platform names. Instead, to remain platform-agnostic, a numeric suffix defines the width in bits. The following integer types can be used in <a class="el" href="namespace_a_w_d.html" title="The namespace used for the complete libawd. ">AWD</a>:</p>
<p>● int8 and uint8</p>
<p>● int16 and uint16</p>
<p>● int32 and <a class="el" href="namespace_a_w_d_1_1_t_y_p_e_s.html#a0633e60becfa73b1f2e7681b000314c0">AWD::TYPES::UINT32</a></p>
<h3><a class="anchor" id="awd_pt2_4_3_3"></a>
Floating-point numbers</h3>
<p>Non-integer numeric fields are referred to as floats, floating point numbers. Like with integers, a numeric suffix explicitly defines the precision. What in C are usually referred to as doubles are simply referred to as floats with a greater bit-width:</p>
<p>● float32</p>
<p>● float64</p>
<p>Float values must always be encoded as IEEE-754 compliant floating point numbers.</p>
<h2><a class="anchor" id="awd_pt2_4_4"></a>
Booleans and true/false values</h2>
<p>Booleans are encoded as a single byte where any non-zero value indicates a true state. False must hence be encoded as 0 (all eight bits equal zero) and any other value will be interpreted as true.</p>
<table class="doxtable">
<tr>
<th>Offset </th><th>Size </th><th>Type </th><th>Description  </th></tr>
<tr>
<td>0 </td><td>1 </td><td>uint8 </td><td>Boolean encoded as an 8 bit integer. Any non-zero value indicates true. </td></tr>
</table>
<h2><a class="anchor" id="awd_pt2_4_5"></a>
Byte arrays</h2>
<p>Whenever a byte array is mentioned, this is a reference to a sequence of arbitrarily formatted bytes. The context defines what the exact format of the content is and it's length, but usually the exact structure is not relevant to <a class="el" href="namespace_a_w_d.html" title="The namespace used for the complete libawd. ">AWD</a> as a format (e.g. with embedded images) and should be treated by a separate module (e.g.a JPEG decoder.)</p>
<h2><a class="anchor" id="awd_pt2_4_5"></a>
Byte arrays</h2>
<p>Two types of character strings are used in <a class="el" href="namespace_a_w_d.html" title="The namespace used for the complete libawd. ">AWD</a>, ConstString and VarString. Both comprise an array of UTF-8 characters without BOM, the only difference being that whereas the length of a ConstString is always defined by the context, a VarString can have variable length in any given context.</p>
<h3><a class="anchor" id="awd_pt2_4_5_1"></a>
ConstString</h3>
<table class="doxtable">
<tr>
<th>Offset </th><th>Size </th><th>Type </th><th>Description  </th></tr>
<tr>
<td>0 </td><td>Context-sensitive </td><td>Byte array </td><td>String content as UTF-8 without BOM. </td></tr>
</table>
<h3><a class="anchor" id="awd_pt2_4_5_2"></a>
VarString</h3>
<p>A VarString can have any length between 0 and 65536 bytes. The length is defined by the first two bytes in the VarString field, which are to be interpreted as a 16 bit unsigned integer.</p>
<table class="doxtable">
<tr>
<th>Offset </th><th>Size </th><th>Type </th><th>Description  </th></tr>
<tr>
<td>0 </td><td>2 </td><td>uint16 </td><td>String length. </td></tr>
<tr>
<td>2 </td><td>Variable </td><td>Byte array </td><td>String content as UTF-8 without BOM. </td></tr>
</table>
<h2><a class="anchor" id="awd_pt2_4_6"></a>
Lists</h2>
<h3><a class="anchor" id="awd_pt2_4_6_1"></a>
ConstList</h3>
<p>TBD </p>
<h3><a class="anchor" id="awd_pt2_4_6_1"></a>
ConstList</h3>
<p>TBD </p>
<h2><a class="anchor" id="awd_pt2_4_7"></a>
Vectors and matrices</h2>
<h3><a class="anchor" id="awd_pt2_4_7_1"></a>
Vectors and matrices are serialized as a one-dimensional list of floating point numbers. The context defines the size of the vector or matrix.</h3>
<p>The precision (32 or 64 bits per float) for vectors and matrices is defined perblock in the block header flag field. N-dimensional vector N-dimensional vectors are encoded as a 1xN matrix.</p>
<h3><a class="anchor" id="awd_pt2_4_7_2"></a>
MxN matrix</h3>
<p>Matrices are encoded as a column-major (col0, col1, ... colN) serial list of 64-bit floating point numbers. For a matrix with N columns and M rows, the total size of resulting byte array is MxNxP bytes, where P is either 4 or 8 depending on the precision used.</p>
<h2><a class="anchor" id="awd_pt2_4_8"></a>
Addresses</h2>
<p>Fields referred to as <a class="el" href="namespace_a_w_d_1_1_t_y_p_e_s.html#a67050e0d5b2ec92455d9df844eefa24b">AWD::TYPES::BADDR</a> fields are numeric block addresses, usually to a previous block in the file (and sometimes to the block itself, but never to a later occurring block). These are always 32-bit unsigned integers, where a null value is allowed (and means no block is referenced.)</p>
<h2><a class="anchor" id="awd_pt2_4_9"></a>
Colors</h2>
<p>Whenever a color is stored in an <a class="el" href="namespace_a_w_d.html" title="The namespace used for the complete libawd. ">AWD</a> file, it is represented by four 8-bit values, defining the red, green, blue and alpha channels respectively. This means that a color is always 32 bits long in total, and that every channel can have 256 possible values.</p>
<h2><a class="anchor" id="awd_pt2_4_10"></a>
Attributes and properties</h2>
<p>The <a class="el" href="namespace_a_w_d.html" title="The namespace used for the complete libawd. ">AWD</a> format is designed to be extendable, both by future versions of <a class="el" href="namespace_a_w_d.html" title="The namespace used for the complete libawd. ">AWD</a> and by user applications. Blocks in an <a class="el" href="namespace_a_w_d.html" title="The namespace used for the complete libawd. ">AWD</a> file can have attributes that can either be user-defined (e.g. for use in a game or physics engine) or defined by the <a class="el" href="namespace_a_w_d.html" title="The namespace used for the complete libawd. ">AWD</a> format specification.</p>
<p>There are two types of attributes, differentiated and referenced by their key/name types:</p>
<p>● Numeric attributes (sometimes called "properties") are used mainly by the file format itself to maintain forward compatibility. The key is a 16-bit unsigned integer IDs, which makes it very compact while allowing for 65535 values. It's however not human-readable so the meaning of a key ID needs to be established in a contract between encoder and parser, e.g. this document.</p>
<p>● Text attributes (sometimes called "user attributes") are suitable for generator transparency (e.g.letting the end-user define them straight into the file.) Keys are VarStrings which means that these attributes are human-readable and more easily human-writable</p>
<h3><a class="anchor" id="awd_pt2_4_10_1"></a>
Attribute lists</h3>
<p>Attributes are organized in a flat list, so that parsers that ignore attributes can skip the entire list in one seek operation. The list is a very simple structure consisting of a 32 bit integer defining it's length, followed by the serialized list of attributes.</p>
<table class="doxtable">
<tr>
<th>Offset </th><th>Size </th><th>Type </th><th>Description  </th></tr>
<tr>
<td>0 </td><td>4 </td><td>uint </td><td>Attribute list length in bytes. </td></tr>
<tr>
<td>4 </td><td>Variable </td><td>Attribute stream </td><td>List of attributes </td></tr>
</table>
<h3><a class="anchor" id="awd_pt2_4_10_2"></a>
Numeric attributes (“properties”)</h3>
<p>Numeric attributes are key/value pairs where the semantics of the key needs to be derived from a mutual understanding between encoder and parser. Attributes like these are used throughout the <a class="el" href="namespace_a_w_d.html" title="The namespace used for the complete libawd. ">AWD</a> format as a way of defining peripheral values for an element, like the number of segments or dimensions of a cube or material properties.</p>
<table class="doxtable">
<tr>
<th>Offset </th><th>Size </th><th>Type </th><th>Description  </th></tr>
<tr>
<td>0 </td><td>2 </td><td>uint16 </td><td>Attribute ID (key) </td></tr>
<tr>
<td>2 </td><td>4 </td><td><a class="el" href="namespace_a_w_d_1_1_t_y_p_e_s.html#a0633e60becfa73b1f2e7681b000314c0">AWD::TYPES::UINT32</a> </td><td>Value length </td></tr>
<tr>
<td>6 </td><td>Variable </td><td>Variable </td><td>Attribute value </td></tr>
</table>
<p>The value length field defines the length of the value data portion of the attribute. The type of the value is defined by the context and attribute ID.</p>
<h3><a class="anchor" id="awd_pt2_4_10_3"></a>
Text attributes (“user attributes”)</h3>
<p>Attributes themselves are key/value pairs with a type field defining the data type of the value. The key (name) of the attribute is a VarString, as defined above in the section called Strings.</p>
<table class="doxtable">
<tr>
<th>Offset </th><th>Size </th><th>Type </th><th>Description  </th></tr>
<tr>
<td>0 </td><td>1 </td><td>uint8 </td><td>Namespace ID. </td></tr>
<tr>
<td>1 </td><td>Variable </td><td>VarString </td><td>Attribute name (key) as string. </td></tr>
<tr>
<td>Variable </td><td>1 </td><td>type </td><td>Attribute type (data type of value). See section "Field type identification". </td></tr>
<tr>
<td>Variable </td><td>4 </td><td><a class="el" href="namespace_a_w_d_1_1_t_y_p_e_s.html#a0633e60becfa73b1f2e7681b000314c0">AWD::TYPES::UINT32</a> </td><td>Value length </td></tr>
<tr>
<td>Variable </td><td>Variable </td><td>Variable </td><td>Attribute value </td></tr>
</table>
<p>At first glance the value length field can seem redundant since the attribute type field implicitly defines the size of the value. However, the length field allows attributes to store arrays of values (though always expressed in bytes, not number of elements.) An attribute value of type int32 with length 12 bytes contains three integer elements. Furthermore, for a parser that does not recognize a particular attribute type, the length field allows the entire value to be skipped.</p>
<p>Because of the length field, string values do not need to be defined as VarStrings with their own length field, but can instead be encoded as ConstStrings, the length of which is defined by the attribute value length field.</p>
<h2><a class="anchor" id="awd_pt2_4_11"></a>
TypedPropertiesLists</h2>
<p>A TypedPropertiesList is used for example to store Shading- /ShadowMap- /and EffectMethods.</p>
<p>It stores a type-ID and a list of properties.</p>
<table class="doxtable">
<tr>
<th>Offset </th><th>Size </th><th>Type </th><th>Description  </th></tr>
<tr>
<td>0 </td><td>2 </td><td>uint16 </td><td>TypedPropertiesList-TypeID </td></tr>
<tr>
<td>2 </td><td>Variable </td><td>NumAttrList </td><td>property-list </td></tr>
<tr>
<td>Variable </td><td>Variable </td><td>UserAttrList </td><td>User properties for method </td></tr>
</table>
<p>The TypePropertiesList-TypeID is defined by the context the TypePropertiesList is used in. Please look into the specification of Shading- / ShadowMap- /and EffectMethods for more information. All TypedProperetiesLists are using the same set of Properties-IDs. As shown in the next Table, for every Value-Type, 100 IDs are reserved. If there will be a need for more IDs per Value-Type, this table can easy be extended.</p>
<h3><a class="anchor" id="awd_pt2_4_11_1"></a>
TypedProperties-IDs</h3>
<table class="doxtable">
<tr>
<th>ID </th><th>Type  </th></tr>
<tr>
<td>1-100 </td><td><a class="el" href="namespace_a_w_d_1_1_t_y_p_e_s.html#a67050e0d5b2ec92455d9df844eefa24b">AWD::TYPES::BADDR</a> </td></tr>
<tr>
<td>101-200 </td><td>Bawd_pt2_5_3 </td></tr>
<tr>
<td>201-300 </td><td>BAWD::TYPES::UINT32 </td></tr>
<tr>
<td>301-400 </td><td>Buint16 </td></tr>
<tr>
<td>401-500 </td><td>Buint8 </td></tr>
<tr>
<td>501-600 </td><td>BString </td></tr>
<tr>
<td>601-700 </td><td>BColor </td></tr>
<tr>
<td>701-800 </td><td>BBool </td></tr>
<tr>
<td>801-900 </td><td>BMatrix(list of awd_pt2_5_1) </td></tr>
</table>
<h2><a class="anchor" id="awd_pt2_4_12"></a>
References and null values</h2>
<p>In cases where null values can exist (such as references to other blocks) Null is represented by zero, which also means it can be interpreted as false if evaluated as a boolean. This also means that in cases where Null needs to be treated as a special case (i.e. block references, namespace handles) zero is not a valid value but will be interpreted as Null.</p>
<h1><a class="anchor" id="awd_pt2_data_block_concept"></a>
The Data Block concept</h1>
<p>The uncompressed file body is a flat sequence of "data blocks" that adhere to a pre-defined structure. The first fields in a block are required to be the same for any type of block, and are referred to as the block's header. The type and length of a block is defined by these fields, allowing full forward-compatibility between an extended <a class="el" href="namespace_a_w_d.html" title="The namespace used for the complete libawd. ">AWD</a> file and an unaware parser, which can determine whether a block type is known and if not skip that block.</p>
<p>Blocks can reference other blocks using their numeric 32-bit IDs. References are required to always be made backwards, meaning that a block can not reference a target block that is defined later in the document than the referring block. This is to speed up parsing and prevent problems with streaming <a class="el" href="namespace_a_w_d.html" title="The namespace used for the complete libawd. ">AWD</a> documents and should not cause any troubles in most realistic use-cases.</p>
<h2><a class="anchor" id="awd_pt2_9"></a>
Anatomy of a block</h2>
<p>All data blocks share a couple of characteristics.</p>
<h3><a class="anchor" id="awd_pt2_9_1"></a>
Block Header</h3>
<p>First, they all begin with a block header which specifies the block ID, type, and length. This must be read by all parsers to decide whether a block can be parsed or should be skipped (by seeking forward the number of bytes specified in the length field.)</p>
<table class="doxtable">
<tr>
<th>Offset </th><th>Size </th><th>Type </th><th>Description  </th></tr>
<tr>
<td>0 </td><td>4 </td><td><a class="el" href="namespace_a_w_d_1_1_t_y_p_e_s.html#a67050e0d5b2ec92455d9df844eefa24b">AWD::TYPES::BADDR</a> </td><td>Block ID </td></tr>
<tr>
<td>4 </td><td>1 </td><td>uint8 </td><td>Block namespace handle. </td></tr>
<tr>
<td>5 </td><td>1 </td><td>uint8 </td><td>Block data type ID. </td></tr>
<tr>
<td>6 </td><td>1 </td><td>uint8 </td><td>Flags (see separate table.) </td></tr>
<tr>
<td>7 </td><td>4 </td><td><a class="el" href="namespace_a_w_d_1_1_t_y_p_e_s.html#a0633e60becfa73b1f2e7681b000314c0">AWD::TYPES::UINT32</a> </td><td>Block data size in bytes. </td></tr>
</table>
<h3><a class="anchor" id="awd_pt2_9_1_1"></a>
Block flags</h3>
<table class="doxtable">
<tr>
<th>Bit</th><th>Name </th><th>Description  </th></tr>
<tr>
<td>01 </td><td>Matrix-Storage-Precision </td><td>Only used if Header-Flag-Bit 04 is set to true </td></tr>
<tr>
<td>02 </td><td>Geometry-Storage-Precision </td><td>Only used if Header-Flag-Bit 04 is set to true </td></tr>
<tr>
<td>03 </td><td>Properties-Storage-Precision </td><td>Only used if Header-Flag-Bit 04 is set to true </td></tr>
<tr>
<td>04 </td><td>Compression </td><td>Defines if Block is compressed </td></tr>
<tr>
<td>05 </td><td>LZMA-Compression </td><td>Only used if bit 04 is set </td></tr>
</table>
<p>The body of a block varies and can theoretically be anything. Generally, the top-level structure of a block usually resembles the following, including the already mentioned header:</p>
<p>Block header: 11 bytes structured according to the table above, defining block ID, namespace, type and length.</p>
<p>● Basic required values: a static condensed list of value-only fields where the order and semantics are defined explicitly by the <a class="el" href="namespace_a_w_d.html" title="The namespace used for the complete libawd. ">AWD</a> file format specification and where every value is required.</p>
<p>● Optional properties: a dynamic list of key/value pairs defined by the <a class="el" href="namespace_a_w_d.html" title="The namespace used for the complete libawd. ">AWD</a> file format specification. See the section “Numeric Attributes” for more info.</p>
<p>● Sub-structure: Lists of logical elements that are hierarchically ordered below this block, but do not have their own blocks, like lists of joints in a skeleton or sub-meshes in a geometry block.</p>
<p>● User attributes: A dynamic list of arbitrary key/value pairs. These can be used for app-specific data or meta-data stored by an encoder user directly.</p>
<h2><a class="anchor" id="awd_pt2_9_2"></a>
Block IDs and addressing</h2>
<p>All blocks have a unique numeric ID, which is used to reference that block from other blocks. The zero block ID indicates that a block will never be referenced and that a parser hence is not required to keep it in memory after it is done with it. These blocks are said to be temporary. Blocks with ID greater than zero are said to be persistent.</p>
<p>Block IDs must be incremented a single step for each block that has an ID. The first persistent block must have ID 1, and the next persistent block have ID 2. Any temporary blocks (that do not have IDs) do not affect this sequence of IDs. Block references must always be made backwards, meaning that the block with ID N can only reference blocks for which the ID is less than N.</p>
<h2><a class="anchor" id="awd_pt2_9_3"></a>
Block namespaces</h2>
<p>A block needs to exist within a namespace, which defines whether it's a standard <a class="el" href="namespace_a_w_d.html" title="The namespace used for the complete libawd. ">AWD</a> block (the Null namespace) or part of an <a class="el" href="namespace_a_w_d.html" title="The namespace used for the complete libawd. ">AWD</a> extension. Namespace handles in block headers and elsewhere are 8-bit numeric IDs which allows an <a class="el" href="namespace_a_w_d.html" title="The namespace used for the complete libawd. ">AWD</a> file to have 255 namespaces on top of the default Null namespace.</p>
<p>All blocks defined in this document belong in the Null namespace, as they are part of the <a class="el" href="namespace_a_w_d.html" title="The namespace used for the complete libawd. ">AWD</a> standard blocks. See the Part III section "Extending AWD" for information about how to use other namespaces when extending the file format.\</p>
<h1><a class="anchor" id="awd_pt2_10"></a>
Block types</h1>
<p>The following list documents the native <a class="el" href="namespace_a_w_d.html" title="The namespace used for the complete libawd. ">AWD</a> block types and the type IDs. All native <a class="el" href="namespace_a_w_d.html" title="The namespace used for the complete libawd. ">AWD</a> blocks are required to be defined in the Null namespace.</p>
<blockquote class="doxtable">
<p><b>cpp-libawd</b><br />
 In libawd this is defined by the <a class="el" href="namespace_a_w_d_1_1_b_l_o_c_k.html#ad248dcc3c94ce1c0f4263f577ebc5a77">block_type</a> property of <a class="el" href="class_a_w_d_1_1_b_a_s_e_1_1_a_w_d_block.html">AWDBlock</a>. </p>
</blockquote>
<blockquote class="doxtable">
<p><b>Away3d</b><br />
 To access the Assets in Away3d directly after they are parsed, you can listen for the AssetEvent.ASSET_COMPLETE and check which kind of Asset was received by using the AssetType.<br />
 You also can listen for spezial kinds of Assets, using the AssetEvent associated with the AssetType (e.g. Event for AssetType.GEOMETRY is AssetEvent.GEOMETRY_COMPLETE).<br />
</p>
</blockquote>
<table class="doxtable">
<tr>
<th>ID </th><th>Block type </th><th>Category </th><th>AssetType </th><th>Added in Version </th><th>updates  </th></tr>
<tr>
<td>1 </td><td>TriangleGeometry </td><td>Geometry/data </td><td>AssetType.GEOMETRY </td><td>2.0 </td><td>2.1 / 3.0 </td></tr>
<tr>
<td>11 </td><td>PrimitiveGeometry </td><td>Geometry/data </td><td>AssetType.GEOMETRY </td><td>2.1 </td><td>&ndash; </td></tr>
<tr>
<td>21 </td><td>Scene </td><td>Scene-objects </td><td>-&mdash; </td><td>&mdash; </td><td>&ndash; </td></tr>
<tr>
<td>22 </td><td>Container </td><td>Scene-objects </td><td>AssetType.CONTAINER </td><td>2.0 </td><td>2.1 </td></tr>
<tr>
<td>23 </td><td>MeshInstance </td><td>Scene-objects </td><td>AssetType.MESH </td><td>2.0 </td><td>2.1 </td></tr>
<tr>
<td>31 </td><td>SkyBox </td><td>Scene-objects </td><td>AssetType.SKYBOX </td><td>2.1 </td><td>&ndash; </td></tr>
<tr>
<td>41 </td><td>Light </td><td>Scene-objects </td><td>AssetType.LIGHT </td><td>2.1 </td><td>&ndash; </td></tr>
<tr>
<td>42 </td><td>Camera </td><td>Scene-objects </td><td>AssetType.CAMERA </td><td>2.1 </td><td>&ndash; </td></tr>
<tr>
<td>43 </td><td>TextureProjector </td><td>Scene-objects </td><td>AssetType.TEXTURE_PROJECTOR </td><td>2.1 </td><td>&ndash; </td></tr>
<tr>
<td>51 </td><td>LightPicker </td><td>Light </td><td>AssetType.LIGHT_PICKER </td><td>2.1 </td><td>&ndash; </td></tr>
<tr>
<td>81 </td><td>StandardMaterial </td><td>Materials </td><td>AssetType.MATERIAL </td><td>2.0 </td><td>2.1 / 3.0 </td></tr>
<tr>
<td>82 </td><td>Texture </td><td>Materials </td><td>AssetType.TEXTURE </td><td>2.0 </td><td>&ndash; </td></tr>
<tr>
<td>83 </td><td>CubeTexture </td><td>Materials </td><td>AssetType.TEXTURE: </td><td>2.1 </td><td>&ndash; </td></tr>
<tr>
<td>91 </td><td>SharedMethod </td><td>Method </td><td>AssetType.EFFECTS_METHOD </td><td>2.1 </td><td>&ndash; </td></tr>
<tr>
<td>92 </td><td>ShadowMethod </td><td>Method </td><td>AssetType.SHADOW_MAP_METHOD </td><td>2.1 </td><td>&ndash; </td></tr>
<tr>
<td>101 </td><td>Skeleton </td><td>Animation </td><td>AssetType.SKELETON </td><td>2.0 </td><td>&ndash; </td></tr>
<tr>
<td>102 </td><td>SkeletonPose </td><td>Animation </td><td>AssetType.SKELETON_POSE </td><td>2.0 </td><td>&ndash; </td></tr>
<tr>
<td>103 </td><td>SkeletonAnimation </td><td>Animation </td><td>AssetType.ANIMATION_NODE </td><td>2.0 </td><td>&ndash; </td></tr>
<tr>
<td>111 </td><td>MeshPose </td><td>Animation </td><td>AssetType.ANIMATION_NODE </td><td>2.1 </td><td>&ndash; </td></tr>
<tr>
<td>112 </td><td>MeshPoseAnimation </td><td>Animation </td><td>AssetType.ANIMATION_NODE </td><td>2.1 </td><td>&ndash; </td></tr>
<tr>
<td>113 </td><td>AnimationSet </td><td>Animation </td><td>AssetType.ANIMATION_SET </td><td>2.1 </td><td>&ndash; </td></tr>
<tr>
<td>121 </td><td>UVAnimation </td><td>Animation </td><td>AssetType.ANIMATION_NODE </td><td>3.0 </td><td>&ndash; </td></tr>
<tr>
<td>122 </td><td>Animator </td><td>Animation </td><td>AssetType.ANIMATOR </td><td>2.1 </td><td>&ndash; </td></tr>
<tr>
<td>133 </td><td>TimeLine </td><td>Animation </td><td></td><td>3.0 </td><td>&ndash; </td></tr>
<tr>
<td>141 </td><td>Sound </td><td>SOUND </td><td></td><td>3.0 </td><td>&ndash; </td></tr>
<tr>
<td>134 </td><td>Textelement </td><td>TEXT </td><td></td><td>3.0 </td><td>&ndash; </td></tr>
<tr>
<td>135 </td><td>FontTable </td><td>TEXT </td><td></td><td>3.0 </td><td>&ndash; </td></tr>
<tr>
<td>253 </td><td>Command </td><td>Misc </td><td>? Create a new CommandEvent ? </td><td>2.1 </td><td>3.0 </td></tr>
<tr>
<td>254 </td><td>Namespace </td><td>Misc </td><td>No Asset created </td><td>2.0 </td><td>&ndash; </td></tr>
<tr>
<td>255 </td><td>Meta-data </td><td>Misc </td><td>No Asset created </td><td>2.0 </td><td>3.0 </td></tr>
</table>
<h1><a class="anchor" id="awd_pt2_11"></a>
Geometry blocks</h1>
<h2><a class="anchor" id="awd_pt2_11_1"></a>
TriangleGeometry (ID 1)</h2>
<p>TriangleGeometry blocks contains geometry data for common triangle meshes.<br />
This might be 3D Triangle Geometries, or 2D Triangle Geometries.<br />
The type of geometry is only indirectly defined, by the SubGeometry-Streams found in the Geometry.<br />
 A geometry is split into subgeometries which in turn contain a number of data streams that define the geometry.<br />
 A triangle geometry block can be referenced by several mesh instances in a scene, so that the same geometry data is used to render several objects saving storage space on disk and memory.</p>
<blockquote class="doxtable">
<p><b>libawd:</b><br />
 <a class="el" href="namespace_a_w_d_1_1_g_e_o_m.html#a5c8a18382d0bf3c857c44411dc436acb">Documentation for ProcessMeshGeometry</a><br />
 <a class="el" href="namespace_a_w_d_1_1_g_e_o_m.html#abd567aff18741d42cddc830866ebb2a8">Documentation for ProcessShapeGeometry</a><br />
 <a class="el" href="class_a_w_d_1_1_b_l_o_c_k_s_1_1_geometry.html">Geometry (AWDBlock)</a><br />
 <a class="el" href="class_a_w_d_1_1_g_e_o_m_1_1_sub_geom.html">SubGeom (Element)</a><br />
</p>
</blockquote>
<p>The top-level structure of a mesh data block is defined by this table:</p>
<table class="doxtable">
<tr>
<th>Offset </th><th>Size </th><th>Type </th><th>Description  </th></tr>
<tr>
<td>0 </td><td>11 </td><td>BlockHeader </td><td><a class="el" href="awd_specs_2.html#awd_pt2_9_1">Block Header</a> </td></tr>
<tr>
<td>11 </td><td>Variable </td><td>VarString </td><td>Look-up name. </td></tr>
<tr>
<td>Variable </td><td>2 </td><td>uint16 </td><td>Number of <a class="el" href="awd_specs_2.html#awd_pt2_11_1_1">Sub-geometry</a>. </td></tr>
<tr>
<td>Variable </td><td>Variable </td><td>NumAttrList </td><td><a class="el" href="awd_specs_2.html#specs_geometry_properties">TriangleGeometry Properties</a> </td></tr>
<tr>
<td>Variable </td><td>Variable </td><td>List of SubMesh </td><td>list of <a class="el" href="awd_specs_2.html#awd_pt2_11_1_1">Sub-geometry</a> </td></tr>
<tr>
<td>Variable </td><td>Variable </td><td>UserAttrList </td><td>User attributes. </td></tr>
</table>
<h3><a class="anchor" id="specs_geometry_properties"></a>
TriangleGeometry Properties</h3>
<table class="doxtable">
<tr>
<th>Property ID </th><th>Name </th><th>Type </th><th>Description </th><th>Default  </th></tr>
<tr>
<td>1 </td><td>UVScaleU </td><td><a class="el" href="namespace_a_w_d_1_1_t_y_p_e_s.html#aa814bc19f707275ab0571a3406f1541d">AWD::TYPES::F64</a> </td><td>UV-scale u value </td><td>1.0 </td></tr>
<tr>
<td>2 </td><td>UVScaleV </td><td><a class="el" href="namespace_a_w_d_1_1_t_y_p_e_s.html#aa814bc19f707275ab0571a3406f1541d">AWD::TYPES::F64</a> </td><td>UV-scale v value </td><td>1.0 </td></tr>
</table>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000001">Todo:</a></b></dt><dd>Might be cleaner to set UVScale as Vertex2x1 in 1 property.<br />
</dd></dl>
<h3><a class="anchor" id="awd_pt2_11_1_1"></a>
Sub-geometry</h3>
<p>A sub-geometry is a per-material division of a triangle geometry.<br />
 Sub-geometries are also used by Away3D to split meshes into buffers that do not exceed platform buffer size limits.<br />
 A <a class="el" href="namespace_a_w_d.html" title="The namespace used for the complete libawd. ">AWD</a> exporter, should take care that no subgeometry exceeds the ressource limits. <br />
 This follows, that even if subgeometry is a per-material division, we might have multiple subgeometries in one geometry that share the same material.</p>
<p>Sub-geometries define their geometry as data streams, condensed lists of numeric values distinguished by type, e.g. vertex positions, face indices and UV coordinates.</p>
<h3><a class="anchor" id="specs_subgeometry"></a>
Structure of a subgeometry in &amp;AWD</h3>
<table class="doxtable">
<tr>
<th>Offset </th><th>Size </th><th>Type </th><th>Description  </th></tr>
<tr>
<td>0 </td><td>4 </td><td><a class="el" href="namespace_a_w_d_1_1_t_y_p_e_s.html#a0633e60becfa73b1f2e7681b000314c0">AWD::TYPES::UINT32</a> </td><td>Length of subgeometry <br />
 (total length of data streams in bytes) </td></tr>
<tr>
<td>4 </td><td>Variable </td><td>NumAttrList </td><td>Sub-mesh properties </td></tr>
<tr>
<td>Variable </td><td>Variable </td><td>List of DataStream </td><td>Geometry data streams </td></tr>
<tr>
<td>Variable </td><td>Variable </td><td>UserAttrList </td><td>User attributes. </td></tr>
</table>
<h3><a class="anchor" id="specs_subgeometry_properties"></a>
SubGeometry Properties</h3>
<table class="doxtable">
<tr>
<th>Property ID </th><th>Name </th><th>Type </th><th>Description </th><th>Default  </th></tr>
<tr>
<td>1 </td><td>UVScaleU </td><td><a class="el" href="namespace_a_w_d_1_1_t_y_p_e_s.html#aa814bc19f707275ab0571a3406f1541d">AWD::TYPES::F64</a> </td><td>UV-scale x value </td><td>1.0 </td></tr>
<tr>
<td>2 </td><td>UVScaleV </td><td><a class="el" href="namespace_a_w_d_1_1_t_y_p_e_s.html#aa814bc19f707275ab0571a3406f1541d">AWD::TYPES::F64</a> </td><td>Sub-mesh properties </td><td>1.0 </td></tr>
<tr>
<td>3 </td><td>UVTransform </td><td>Matrix3x2 </td><td>UV Tranformation for SubGeometry</td><td>Identity Matrix </td></tr>
</table>
<p>A normal 3D SubGeometry does not use the UVTranform property, but a 2D SubGeometry might need it.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000002">Todo:</a></b></dt><dd>Might be cleaner to set UVScale as Vertex2x1 in 1 property.<br />
Not sure we need the UVTranform for the 2D Geometry</dd></dl>
<p>A subgeometry can contain any number of data streams (as long as it does not exceed the size limit inherited by the 32-bit length field).</p>
<h3><a class="anchor" id="specs_datastreams"></a>
Data streams</h3>
<p>A data stream is a condensed sequence of geometry data, such as vertex positions, UV coordinates or face indices.</p>
<p>The below table defines the structure of a data stream.</p>
<table class="doxtable">
<tr>
<th>Offset </th><th>Size </th><th>Type </th><th>Description  </th></tr>
<tr>
<td>0 </td><td>1 </td><td>uint8 </td><td><a class="el" href="awd_specs_2.html#specs_datastream_types">Data stream types</a> </td></tr>
<tr>
<td>1 </td><td>1 </td><td>uint8 </td><td>Content data type.<br />
 <b>ATTENTION:</b> <br />
 This was never used by the official parser, and some exporters do not even set it. </td></tr>
<tr>
<td>2 </td><td>4 </td><td><a class="el" href="namespace_a_w_d_1_1_t_y_p_e_s.html#a0633e60becfa73b1f2e7681b000314c0">AWD::TYPES::UINT32</a> </td><td>Length of data stream in bytes </td></tr>
<tr>
<td>5 </td><td>Variable </td><td>List of GeometrySP/int16 </td><td>Data stream contents </td></tr>
</table>
<blockquote class="doxtable">
<p><b>libawd:</b><br />
 In libawd a DataStream only exists while writing to file. <br />
 For each DataStream a <a class="el" href="class_a_w_d_1_1_g_e_o_m_1_1_data_stream_recipe.html">DataStreamRecipe</a> is available to help defining the resulting DataStream. </p>
</blockquote>
<h3><a class="anchor" id="specs_datastream_types"></a>
Data stream types</h3>
<p>The following data-stream-types are defined by AWD. <br />
For custom stream-types, best use the reserved ids as long as possible.</p>
<table class="doxtable">
<tr>
<th>ID </th><th>Stream type  </th></tr>
<tr>
<td>1 </td><td>3D Vertex positions </td></tr>
<tr>
<td>2 </td><td>Face indices </td></tr>
<tr>
<td>3 </td><td>UV coordinates </td></tr>
<tr>
<td>4 </td><td>Vertex normals </td></tr>
<tr>
<td>5 </td><td>Vertex tangents (not written by any exporter yet) </td></tr>
<tr>
<td>6 </td><td>Joint index </td></tr>
<tr>
<td>7 </td><td>Joint weight </td></tr>
<tr>
<td>8 </td><td>2D Vertex positions </td></tr>
<tr>
<td>9 </td><td>Combined 3D vertex-stream length 13 (work in progress) </td></tr>
<tr>
<td>10 </td><td>Combined 2D vertex-stream length 9 (work in progress) </td></tr>
<tr>
<td>11 </td><td>Combined 2D vertex-stream length 5 (work in progress) </td></tr>
<tr>
<td>200-255 </td><td>Reserved for custom-streams </td></tr>
</table>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000003">Todo:</a></b></dt><dd>The IDs 9, 10 and 11 are work in progress for the AWD3.0 the specs should be finalized soon.</dd></dl>
<p>The internal structure of the values in a data stream varies between stream types, and are described in the next sections.</p>
<h3><a class="anchor" id="awd_pt2_11_1_3"></a>
Content structure of 3D vertex positions, vertex normals, and vertex tangents data streams</h3>
<p>All these streams consist of a flattened serialized list of number triplets, with the general form:<br />
X1,Y1,Z1, X2,Y2,Z2, X2,Y2,Z2 ... XN,YN,ZN.<br />
 This means that the total number of value items in a stream of one of these types is always a multiple of three.</p>
<h3><a class="anchor" id="awd_pt2_11_1_4"></a>
Content structure of face index data streams</h3>
<p>Face index data streams define triangles as triplets of index integers. <br />
The indices refer to vertices defined in the vertex stream, where index zero refers to the vertex defined by the first triplet in the vertex stream. <br />
An index i in the face index data stream refers to the vertex defined by the three subsequent floating point numbers starting at index 3i in the vertex stream.<br />
 </p>
<h3><a class="anchor" id="awd_pt2_11_1_5"></a>
Content structure of UV coordinate and 2D vertex positions data streams</h3>
<p>The UV coordinate stream is very similar to the vertex position stream except each item is a two-dimensional vector which defines a UV pair. <br />
This means that the total number of values in a UV coordinate data stream is always a multiple of two. <br />
The UV pair with index i comprises the two subsequent floating point numbers starting at 2i in the UV stream, and defines the UV coordinate for the vertex defined by the three subsequent floating point numbers starting at index 3i in the vertex stream.<br />
In some applications, it makes sense to have more than one set of UV coordinates. This can be achieved simply by including several streams of the UV type in a sub-geometry.<br />
 The stream-type <b>2D Vertex position</b> is not used yet, but might be in future</p>
<h3><a class="anchor" id="awd_pt2_11_1_6"></a>
Content structure of Joint index and weight streams</h3>
<p>The joint index and joint weight streams are used to bind the vertices of a mesh to a joint in a skeleton. They must have the same number of elements. The number of joints that affect a vertex needs to be constant throughout the mesh, which means that the number of values in these streams are even multiples of the number of vertices in the mesh. For the sake of example, lets define N as the number of joints per vertex. If N=2, that means that each vertex can be bound to two joints. For each vertex in the vertex data stream, N joint weights are stored in the joint weight stream. At the corresponding index in the joint index stream is a reference to which joint this weight concerns, stored as an index into the list of joints in the skeleton.</p>
<p>Continuing the example of N=2, consider the following two streams:</p>
<p>Joint indices: 0, 1, 3, 0</p>
<p>Joint weights: 0.6, 0.4, 1.0, 0</p>
<p>The joint weights for the first vertex in the vertex stream are defined by the first two numbers in these streams (since N=2). The first joint to which this vertex is bound is the one with index 0, and the bind is weighted at 0.6. The same vertex is also bound to joint 1, for which the weight is 0.4. The second pair in each stream defines the two bindings for the second vertex of this sub-mesh. In this example, this vertex is bound to joint 3 which is weighted at 1.0, and also to joint 0. Note however that this last binding has zero weight, which in practice means that it will be ignored. The sum of all weights on a vertex must always be 1.0. In this example the first pair has a sum of 1.0 (0.6 and 0.4) and so does the second pair (1.0 and 0.0), and they are thus both correctly formatted.</p>
<p>Weights should also be ordered from largest to smallest, so that any zero weights are always at the end. This is because the rendering engine might discard any weights after the first zero weight as a performance optimization. Away3D does this. Since <a class="el" href="namespace_a_w_d.html" title="The namespace used for the complete libawd. ">AWD</a> enforces a constant number of joints per vertex, there can often be cases where it is possible to bind more joints to a vertex than what is necessary for that vertex. In those cases the index can be set to any number, and the weight to zero as in the example above.</p>
<h3><a class="anchor" id="awd_pt2_11_1_8"></a>
Content structure of Combined 3D vertex position data streams with length 13</h3>
<p>In contrast to the other stream-types, the combined data-streams always store numbers as float32.<br />
This is because they are supposed to be uploaded to GPU directly, what expects numbers as float32.<br />
 The combined Vertex stream type defines this data for each 3D vertex:</p>
<table class="doxtable">
<tr>
<th>name </th><th>type  </th></tr>
<tr>
<td>position </td><td>3 x float32 </td></tr>
<tr>
<td>normal </td><td>3 x float32 </td></tr>
<tr>
<td>tangent </td><td>3 x float32 </td></tr>
<tr>
<td>uv1 </td><td>2 x float32 </td></tr>
<tr>
<td>uv2 </td><td>2 x float32 </td></tr>
</table>
<h3><a class="anchor" id="awd_pt2_11_1_7"></a>
Content structure of Combined 2D vertex position data streams with length 9</h3>
<p>In contrast to the other stream-types, the combined data-streams always store numbers as float32.<br />
This is because they are supposed to be uploaded to GPU directly, what expects numbers as float32.<br />
 At the moment, the AwayExtensions FlashPro export this data for each 2D vertex:</p>
<table class="doxtable">
<tr>
<th>name </th><th>type  </th></tr>
<tr>
<td>position </td><td>2 x float32 </td></tr>
<tr>
<td>curve-type </td><td>float32 </td></tr>
<tr>
<td>curve.u </td><td>float32 </td></tr>
<tr>
<td>curve.v </td><td>float32 </td></tr>
<tr>
<td>red </td><td>float32 </td></tr>
<tr>
<td>green </td><td>float32 </td></tr>
<tr>
<td>blue </td><td>float32 </td></tr>
<tr>
<td>alpha </td><td>float32 </td></tr>
</table>
<h3><a class="anchor" id="awd_pt2_11_1_7"></a>
Content structure of Combined 2D vertex position data streams with length 9</h3>
<p>In contrast to the other stream-types, the combined data-streams always store numbers as float32.<br />
This is because they are supposed to be uploaded to GPU directly, what expects numbers as float32.<br />
 In the final version of the shape-rendering in AwayJS, we will not need the vertex-colors.<br />
So the final final specs for 2D output might look like this:</p>
<table class="doxtable">
<tr>
<th>name </th><th>type  </th></tr>
<tr>
<td>position </td><td>2 x float32 </td></tr>
<tr>
<td>curve-type </td><td>float32 </td></tr>
<tr>
<td>curve.u </td><td>float32 </td></tr>
<tr>
<td>curve.v </td><td>float32 </td></tr>
</table>
<p><br />
<br />
</p>
<h2><a class="anchor" id="awd_pt2_11_2"></a>
PrimitiveGeometry (ID 11)</h2>
<p>Primitive blocks are a type of geometry meta-data block in that it doesn't actually contain any geometry data.<br />
Rather, the meta-data in the block defines the type of primitive and it's properties, and the actual geometry is re-constructed by the receiving end using these properties.<br />
 The primitive block defines a field for the primitive type followed by a numeric attribute list defining properties such as dimensions, geometric density etc. <br />
 Like most other blocks, user attributes can be appended to this block through it's user attribute list.<br />
 </p><blockquote class="doxtable">
<p><b>libawd</b>:<br />
 The PrimitiveGeometry in libawd: <a class="el" href="class_a_w_d_1_1_b_l_o_c_k_s_1_1_primitive.html">Primitve (AWDBlock)</a></p>
<p></p>
</blockquote>
<table class="doxtable">
<tr>
<th>Offset </th><th>Size </th><th>Type </th><th>Description  </th></tr>
<tr>
<td>0 </td><td>11 </td><td>BlockHeader </td><td><a class="el" href="awd_specs_2.html#awd_pt2_9_1">Block Header</a> </td></tr>
<tr>
<td>11 </td><td>variable </td><td>VarString </td><td>Look up name </td></tr>
<tr>
<td>variable </td><td>1 </td><td>uint8 </td><td><a class="el" href="awd_specs_2.html#primitive_types">Primitive Types</a> </td></tr>
<tr>
<td>variable </td><td>Variable </td><td>NumAttrList </td><td>Primitive properties. </td></tr>
<tr>
<td>Variable </td><td>Variable </td><td>UserAttrList </td><td>User attributes. </td></tr>
</table>
<h3><a class="anchor" id="primitive_types"></a>
Primitive Types</h3>
<p>The type field defines the primitive type according to the following table:</p>
<table class="doxtable">
<tr>
<th>Type ID </th><th>Primitive type  </th></tr>
<tr>
<td>1 </td><td>Plane </td></tr>
<tr>
<td>2 </td><td>Cube </td></tr>
<tr>
<td>3 </td><td>Sphere </td></tr>
<tr>
<td>4 </td><td>Cylinder </td></tr>
<tr>
<td>5 </td><td>Cone </td></tr>
<tr>
<td>6 </td><td>Capsule </td></tr>
<tr>
<td>7 </td><td>Torus </td></tr>
</table>
<p>Primitives are making use of the same IDs as a Typed-Properties-List.</p>
<h3><a class="anchor" id="awd_pt2_11_2_1"></a>
PlaneGeometry (Primitve-Type = 1)</h3>
<table class="doxtable">
<tr>
<th>ID </th><th>Name </th><th>Type </th><th>Default  </th></tr>
<tr>
<td>101 </td><td>width </td><td>geometrySP </td><td>100 </td></tr>
<tr>
<td>102 </td><td>height </td><td>geometrySP </td><td>100 </td></tr>
<tr>
<td>301 </td><td>segmentsW </td><td>uint16 </td><td>1 </td></tr>
<tr>
<td>302 </td><td>segmentsH </td><td>uint16 </td><td>1 </td></tr>
<tr>
<td>701 </td><td>yup </td><td>bool </td><td>true </td></tr>
<tr>
<td>702 </td><td>doubleSided</td><td>bool </td><td>false </td></tr>
</table>
<h3><a class="anchor" id="awd_pt2_11_2_2"></a>
CubeGeometry (Primitve-Type = 2)</h3>
<table class="doxtable">
<tr>
<th>ID </th><th>Name </th><th>Type </th><th>Default  </th></tr>
<tr>
<td>101 </td><td>width </td><td>geometrySP </td><td>100 </td></tr>
<tr>
<td>102 </td><td>height </td><td>geometrySP </td><td>100 </td></tr>
<tr>
<td>103 </td><td>depth </td><td>geometrySP </td><td>100 </td></tr>
<tr>
<td>301 </td><td>segmentsW </td><td>uint16 </td><td>1 </td></tr>
<tr>
<td>302 </td><td>segmentsH </td><td>uint16 </td><td>1 </td></tr>
<tr>
<td>303 </td><td>segmentsD </td><td>uint16 </td><td>1 </td></tr>
<tr>
<td>701 </td><td>tile6 </td><td>bool </td><td>true </td></tr>
</table>
<h3><a class="anchor" id="awd_pt2_11_2_3"></a>
SphereGeometry (Primitve-Type = 3)</h3>
<table class="doxtable">
<tr>
<th>ID </th><th>Name </th><th>Type </th><th>Default  </th></tr>
<tr>
<td>101 </td><td>radius </td><td>geometrySP </td><td>50 </td></tr>
<tr>
<td>301 </td><td>segmentsW </td><td>uint16 </td><td>16 </td></tr>
<tr>
<td>302 </td><td>segmentsH </td><td>uint16 </td><td>12 </td></tr>
<tr>
<td>701 </td><td>yup </td><td>bool </td><td>true </td></tr>
</table>
<h3><a class="anchor" id="awd_pt2_11_2_4"></a>
CylinderGeometry (Primitve-Type = 4)</h3>
<table class="doxtable">
<tr>
<th>ID </th><th>Name </th><th>Type </th><th>Default  </th></tr>
<tr>
<td>101 </td><td>topRadius </td><td>geometrySP </td><td>50 </td></tr>
<tr>
<td>102 </td><td>bottomRadius </td><td>geometrySP </td><td>50 </td></tr>
<tr>
<td>103 </td><td>height </td><td>geometrySP </td><td>100 </td></tr>
<tr>
<td>301 </td><td>segmentsW </td><td>uint16 </td><td>16 </td></tr>
<tr>
<td>302 </td><td>segmentsH </td><td>uint16 </td><td>1 </td></tr>
<tr>
<td>701 </td><td>topClosed </td><td>bool </td><td>true </td></tr>
<tr>
<td>702 </td><td>bottomClosed </td><td>bool </td><td>true </td></tr>
<tr>
<td>703 </td><td>yup </td><td>bool </td><td>true </td></tr>
<tr>
<td>704 </td><td>surfaceClosed </td><td>bool </td><td>true </td></tr>
</table>
<h3><a class="anchor" id="awd_pt2_11_2_5"></a>
ConeGeometry (Primitve-Type = 5)</h3>
<table class="doxtable">
<tr>
<th>ID </th><th>Name </th><th>Type </th><th>Default  </th></tr>
<tr>
<td>101 </td><td>radius </td><td>geometrySP </td><td>50 </td></tr>
<tr>
<td>102 </td><td>height </td><td>geometrySP </td><td>100 </td></tr>
<tr>
<td>301 </td><td>segmentsW </td><td>uint16 </td><td>16 </td></tr>
<tr>
<td>302 </td><td>segmentsH </td><td>uint16 </td><td>1 </td></tr>
<tr>
<td>701 </td><td>closed </td><td>bool </td><td>true </td></tr>
<tr>
<td>702 </td><td>yup </td><td>bool </td><td>true </td></tr>
</table>
<h3><a class="anchor" id="awd_pt2_11_2_6"></a>
CapsuleGeometry (Primitve-Type = 6)</h3>
<table class="doxtable">
<tr>
<th>ID </th><th>Name </th><th>Type </th><th>Default  </th></tr>
<tr>
<td>101 </td><td>radius </td><td>geometrySP </td><td>50 </td></tr>
<tr>
<td>102 </td><td>height </td><td>geometrySP </td><td>100 </td></tr>
<tr>
<td>301 </td><td>segmentsW </td><td>uint16 </td><td>16 </td></tr>
<tr>
<td>302 </td><td>segmentsH </td><td>uint16 </td><td>15 </td></tr>
<tr>
<td>701 </td><td>yup </td><td>bool </td><td>true </td></tr>
</table>
<h3><a class="anchor" id="awd_pt2_11_2_7"></a>
TorusGeometry (Primitve-Type = 7)</h3>
<table class="doxtable">
<tr>
<th>ID </th><th>Name </th><th>Type </th><th>Default  </th></tr>
<tr>
<td>101 </td><td>radius </td><td>geometrySP </td><td>50 </td></tr>
<tr>
<td>102 </td><td>tubeRadius </td><td>geometrySP </td><td>50 </td></tr>
<tr>
<td>301 </td><td>segmentsR </td><td>uint16 </td><td>16 </td></tr>
<tr>
<td>302 </td><td>segmentsT </td><td>uint16 </td><td>8 </td></tr>
<tr>
<td>701 </td><td>yup </td><td>bool </td><td>true </td></tr>
</table>
<p><br />
<br />
 </p>
<h1><a class="anchor" id="awd_pt2_12"></a>
Scene object blocks</h1>
<p>Scene graph blocks are spatial objects that can be added to a scene graph.</p>
<h2><a class="anchor" id="awd_pt2_12_1"></a>
Scene Header</h2>
<p>They share the same first three fields, defined below.</p>
<table class="doxtable">
<tr>
<th>Offset </th><th>Size </th><th>Type </th><th>Description  </th></tr>
<tr>
<td>0 </td><td>4 </td><td><a class="el" href="namespace_a_w_d_1_1_t_y_p_e_s.html#a67050e0d5b2ec92455d9df844eefa24b">AWD::TYPES::BADDR</a> </td><td>Parent ID (Numeric). Reference to a previously defined scene graph object. </td></tr>
<tr>
<td>4 </td><td>Variable </td><td>Matrix4x3 </td><td>matrix Transform </td></tr>
<tr>
<td>Variable </td><td>Variable </td><td>VarString </td><td>Look-up name. </td></tr>
</table>
<p>The subsequent sections of a scene graph block differ between the various block types.</p>
<h2><a class="anchor" id="awd_pt2_12_2"></a>
Scene (ID 21)</h2>
<p>The scene is a special case of the scene graph blocks. It's the top-level element in the scene graph, and can not have a parent. Hence, the parent field must always be null (zero) and should be ignored by parsers. In addition to the common fields that all scene object blocks share, scene blocks only have an empty numeric attribute list, and any number of user attributes.</p>
<table class="doxtable">
<tr>
<th>Offset </th><th>Size </th><th>Type </th><th>Description  </th></tr>
<tr>
<td>0 </td><td>11 </td><td>BlockHeader </td><td><a class="el" href="awd_specs_2.html#awd_pt2_9_1">Block Header</a> </td></tr>
<tr>
<td>11 </td><td>Variable </td><td>SceneHeader </td><td><a class="el" href="awd_specs_2.html#awd_pt2_12_1">Scene Header</a> </td></tr>
<tr>
<td>Variable </td><td>Variable </td><td>NumAttrList </td><td>Scene properties(unused in this version.) </td></tr>
<tr>
<td>Variable </td><td>Variable </td><td>UserAttrList </td><td>User attributes. </td></tr>
</table>
<h2><a class="anchor" id="awd_pt2_12_3"></a>
Container (ID 22)</h2>
<p>Containers are objects to which other scene-graph objects can be parented, but that don't have any volume or visual appearance on their own. Containers like scenes only have an empty numeric attribute list and a user attribute list with optional content.</p>
<table class="doxtable">
<tr>
<th>Offset </th><th>Size </th><th>Type </th><th>Description  </th></tr>
<tr>
<td>0 </td><td>11 </td><td>BlockHeader </td><td><a class="el" href="awd_specs_2.html#awd_pt2_9_1">Block Header</a> </td></tr>
<tr>
<td>11 </td><td>Variable </td><td>SceneHeader </td><td><a class="el" href="awd_specs_2.html#awd_pt2_12_1">Scene Header</a> </td></tr>
<tr>
<td>0 </td><td>Variable </td><td>NumAttrList </td><td><a class="el" href="awd_specs_2.html#container_properties">Container Properties.</a> </td></tr>
<tr>
<td>Variable </td><td>Variable </td><td>UserAttrList </td><td>User attributes. </td></tr>
</table>
<p>Container block include the common scene object fields</p>
<h3><a class="anchor" id="container_properties"></a>
Container Properties.</h3>
<table class="doxtable">
<tr>
<th>ID </th><th>Name </th><th>Type </th><th>Description </th><th>Default  </th></tr>
<tr>
<td>1 </td><td>pivotX </td><td>awd_pt2_5_1 </td><td>- </td><td>0 </td></tr>
<tr>
<td>2 </td><td>pivotY </td><td>awd_pt2_5_1 </td><td>- </td><td>0 </td></tr>
<tr>
<td>3 </td><td>pivotZ </td><td>awd_pt2_5_1 </td><td>- </td><td>0 </td></tr>
<tr>
<td>4 </td><td>visibility </td><td>uint8 </td><td>Not really used yet </td><td>true </td></tr>
</table>
<h2><a class="anchor" id="awd_pt2_12_4"></a>
MeshInstance (ID 23)</h2>
<p>MeshInstance blocks define what is probably the most common item in a scene, mesh objects. The geometry is defined by a geometry block elsewhere in the file, and can hence be re-used by several mesh instances.</p>
<p>In addition to the common scene block fields, mesh instances define a reference to the mesh data block, as well as a numeric property list and user attributes.</p>
<table class="doxtable">
<tr>
<th>Offset </th><th>Size </th><th>Type </th><th>Description  </th></tr>
<tr>
<td>0 </td><td>11 </td><td>BlockHeader </td><td><a class="el" href="awd_specs_2.html#awd_pt2_9_1">Block Header</a> </td></tr>
<tr>
<td>11 </td><td>Variable </td><td>SceneHeader </td><td><a class="el" href="awd_specs_2.html#awd_pt2_12_1">Scene Header</a> </td></tr>
<tr>
<td>Variable </td><td>4 </td><td><a class="el" href="namespace_a_w_d_1_1_t_y_p_e_s.html#a67050e0d5b2ec92455d9df844eefa24b">AWD::TYPES::BADDR</a> </td><td>ID of mesh data block. </td></tr>
<tr>
<td>Variable </td><td>2 </td><td>uint16 </td><td>Number of materials </td></tr>
<tr>
<td>Variable </td><td>Variable </td><td>List of <a class="el" href="namespace_a_w_d_1_1_t_y_p_e_s.html#a67050e0d5b2ec92455d9df844eefa24b">AWD::TYPES::BADDR</a> </td><td>Material IDs </td></tr>
<tr>
<td>Variable </td><td>Variable </td><td>NumAttrList </td><td>Mesh instance properties </td></tr>
<tr>
<td>Variable </td><td>Variable </td><td>UserAttrList </td><td>Mesh instance userattributes. </td></tr>
</table>
<p>The MeshInstance-Properties includes the Container-properties.</p>
<table class="doxtable">
<tr>
<th>ID </th><th>Name </th><th>Type </th><th>Description </th><th>Default  </th></tr>
<tr>
<td>5 </td><td>CastShadows </td><td>bool </td><td>If the mesh Instance cast a shadow </td><td>true </td></tr>
</table>
<h2><a class="anchor" id="awd_pt2_12_5"></a>
Skybox (ID 31)</h2>
<p>A SkyBox renders a 360° panorama around your scene. The origin of this panorama will always appear to be the viewers position. The SkyBox makes use of a CubeTextureBlock, to access the 6 bitmaps it needs.</p>
<table class="doxtable">
<tr>
<th>Offset </th><th>Size </th><th>Type </th><th>Description  </th></tr>
<tr>
<td>0 </td><td>11 </td><td>BlockHeader </td><td><a class="el" href="awd_specs_2.html#awd_pt2_9_1">Block Header</a> </td></tr>
<tr>
<td>11 </td><td>Variable </td><td>VarString </td><td>Look-up name. </td></tr>
<tr>
<td>Variable </td><td>4 </td><td><a class="el" href="namespace_a_w_d_1_1_t_y_p_e_s.html#a67050e0d5b2ec92455d9df844eefa24b">AWD::TYPES::BADDR</a> </td><td>Block-ID of CubeTextureBlock </td></tr>
<tr>
<td>Variable </td><td>Variable </td><td>NumAttrList </td><td>SkyBox properties (none in this version.) </td></tr>
<tr>
<td>Variable </td><td>Variable </td><td>UserAttrList </td><td>SkyBox user attributes. </td></tr>
</table>
<h2><a class="anchor" id="awd_pt2_12_6"></a>
Light (ID 41)</h2>
<p>Light blocks represent light-sources in the scene that are used for lighting/shading of objects with compatible materials. Light blocks have a type field that defines what kind of light source the block represents, and a numeric attribute list with lamp properties. The following is not relevant for AwayBuilder atm, but could be in future versions, and will be relevant for AWDToolsC4D. Lights are used by LightPicker-Blocks, so they have to be parsed before this LightPicker. This restriction excludes the LightPicker-Block of beeing a valid Block for the Scene.graph. Instead of the local-tranformation matrix, the AWD-exporter should write the global-tranformation-matrix into the Sceneheader of a light-object. This provides a way to get the light-object-position for a light thats not part of the (<a class="el" href="namespace_a_w_d.html" title="The namespace used for the complete libawd. ">AWD</a>) scene-graph. The CommandBlock (with action = “PutIntoSceneGraph”) provides a way to put the Light at its correct place in the SceneGraph.</p>
<table class="doxtable">
<tr>
<th>Offset </th><th>Size </th><th>Type </th><th>Description  </th></tr>
<tr>
<td>0 </td><td>11 </td><td>BlockHeader </td><td><a class="el" href="awd_specs_2.html#awd_pt2_9_1">Block Header</a> </td></tr>
<tr>
<td>11 </td><td>Variable </td><td>SceneHeader </td><td><a class="el" href="awd_specs_2.html#awd_pt2_12_1">Scene Header</a> </td></tr>
<tr>
<td>Variable </td><td>1 </td><td>uint8 </td><td>Light source type. </td></tr>
<tr>
<td>Variable </td><td>Variable </td><td>NumAttrList </td><td>Light source properties´(see separate table.) the shadowMapper is includet as properties. </td></tr>
<tr>
<td>Variable </td><td>Variable </td><td>UserAttrList </td><td>User attributes. </td></tr>
</table>
<p>Table 20: Lamp block fields (in addition to common scene block fields).</p>
<p>Light source types</p>
<table class="doxtable">
<tr>
<th>Type ID </th><th>Light type  </th></tr>
<tr>
<td>1 </td><td>Point Light </td></tr>
<tr>
<td>2 </td><td>Directional Light </td></tr>
</table>
<p>The light source properties are defined as a list of numeric attributes, and can contain any of the attributes defined in this table. Some properties are only used for certain types of light sources. The ShadowMapper is defined within the Properties.</p>
<p>Light Properties P = PointLight, D = DirectionalLight</p>
<table class="doxtable">
<tr>
<th>ID </th><th>Name </th><th>Type </th><th>P </th><th>D </th><th>Description </th><th>Default  </th></tr>
<tr>
<td>1 </td><td>radius </td><td>awd_pt2_5_3 </td><td>+ </td><td>- </td><td>A radius at which the light intensity starts to decay. </td><td>90000 </td></tr>
<tr>
<td>2 </td><td>falloff </td><td>awd_pt2_5_3 </td><td>+ </td><td>- </td><td>The radius at which the light intensity reaches zero (objects further from the light-source won't be affected.) </td><td>100000 </td></tr>
<tr>
<td>3 </td><td>Color </td><td>color </td><td>+ </td><td>+ </td><td>Color of the light. </td><td>0xffffff </td></tr>
<tr>
<td>4 </td><td>Specular </td><td>awd_pt2_5_3 </td><td>+ </td><td>+ </td><td>Intensity of specular light. </td><td>1.0 </td></tr>
<tr>
<td>5 </td><td>Diffuse </td><td>awd_pt2_5_3 </td><td>+ </td><td>+ </td><td>Intensity of diffuse light. </td><td>1.0 </td></tr>
<tr>
<td>7 </td><td>Ambient-Color </td><td>color </td><td>+ </td><td>+ </td><td>- </td><td>0xffffff </td></tr>
<tr>
<td>8 </td><td>Ambient-Level </td><td>awd_pt2_5_3 </td><td>+ </td><td>+ </td><td>- </td><td>1.0 </td></tr>
<tr>
<td>9 </td><td>ShadowMapperType </td><td>uint8 </td><td>+ </td><td>+ </td><td>defines the type of shadowmapper to use. if this is !=0, castShadows=false; </td><td>0 </td></tr>
<tr>
<td>10 </td><td>DepthMapSize </td><td>uint8 </td><td>+ </td><td>+ </td><td>shadowMapper-property Options are [256, 512, 2048] </td><td>2048 </td></tr>
<tr>
<td>11 </td><td>CoverageRatio </td><td>awd_pt2_5_3 </td><td>+ </td><td>+ </td><td>shadowMapper-property </td><td>0.5 </td></tr>
<tr>
<td>12 </td><td>CascadesNum </td><td>uint16 </td><td>+ </td><td>+ </td><td>shadowMapper-property </td><td>3 </td></tr>
<tr>
<td>21 </td><td>directionX </td><td>awd_pt2_5_1 </td><td>- </td><td>+ </td><td>The direction of the light (x) </td><td>0 </td></tr>
<tr>
<td>22 </td><td>directionY </td><td>awd_pt2_5_1 </td><td>- </td><td>+ </td><td>The direction of the light (y) </td><td>-1 </td></tr>
<tr>
<td>23 </td><td>directionZ </td><td>awd_pt2_5_1 </td><td>- </td><td>+ </td><td>The direction of the light (z) </td><td>1 </td></tr>
<tr>
<td>24 </td><td>pivotX </td><td>awd_pt2_5_1 </td><td>+ </td><td>- </td><td>- </td><td>0 </td></tr>
<tr>
<td>25 </td><td>pivotY </td><td>awd_pt2_5_1 </td><td>+ </td><td>- </td><td>- </td><td>0 </td></tr>
<tr>
<td>26 </td><td>pivotZ </td><td>awd_pt2_5_1 </td><td>+ </td><td>- </td><td>- </td><td>0 </td></tr>
</table>
<p>Table 21: Light block properties.</p>
<p>Shadow Mapper</p>
<p>The TypeID of the Shadowmapper is stored as Light-Property 9.</p>
<p>The default TypeID is 0 = no ShadowMapper. If a ShadowMapper is set, (TypeID!=0), light.castShadows is set to true. </p><table class="doxtable">
<tr>
<th>Type ID </th><th>Shadow Mapper </th><th>type Category  </th></tr>
<tr>
<td>1 </td><td>DirectionalShadowMapper </td><td>Mapper for DirectionalLights </td></tr>
<tr>
<td>2 </td><td>NearDirectionalShadowMapper </td><td>Mapper for DirectionalLights </td></tr>
<tr>
<td>3 </td><td>CascadeShadowMapper </td><td>Mapper for DirectionalLights </td></tr>
<tr>
<td>4 </td><td>CubeMapShadowMapper </td><td>Mapper for PointLights </td></tr>
</table>
<p>All ShadowMapper-Properties are stored as Light-Properties.</p>
<p>DirectionalShadowMapper (ShadowMapperID = 1)</p>
<table class="doxtable">
<tr>
<th>ID </th><th>Name </th><th>Type </th><th>Default  </th></tr>
<tr>
<td>10 </td><td>DepthMapSize </td><td>uint8 </td><td>Defaults to 2048. Options are [256, 512, 2048] </td></tr>
</table>
<p>NearDirectionalShadowMapper (ShadowMapperID = 2)</p>
<table class="doxtable">
<tr>
<th>ID </th><th>Name </th><th>Type </th><th>Default  </th></tr>
<tr>
<td>10 </td><td>DepthMapSize </td><td>uint8 </td><td>Defaults to 2048. Options are [256, 512, 2048] </td></tr>
<tr>
<td>11 </td><td>CoverageRatio </td><td>awd_pt2_5_3 </td><td>default = 0.5 </td></tr>
</table>
<p>CascadeShadowMapper (ShadowMapperID = 3)</p>
<table class="doxtable">
<tr>
<th>ID </th><th>Name </th><th>Type </th><th>Default  </th></tr>
<tr>
<td>10 </td><td>DepthMapSize </td><td>uint8 </td><td>Defaults to 2048. Options are [256, 512, 2048] </td></tr>
<tr>
<td>12 </td><td>Number of Cascades </td><td>uint16 </td><td>Defaults to 3. Options are [1, 2, 3, 4] </td></tr>
</table>
<p>CubeMapShadowMapper (ShadowMapperID = 4)</p>
<table class="doxtable">
<tr>
<th>ID </th><th>Name </th><th>Type </th><th>Default  </th></tr>
<tr>
<td>10 </td><td>DepthMapSize </td><td>uint8 </td><td>Defaults to 512. Options are [256, 512, 1024] </td></tr>
</table>
<h2><a class="anchor" id="awd_pt2_12_7"></a>
Camera (ID 42)</h2>
<p>Camera blocks in <a class="el" href="namespace_a_w_d.html" title="The namespace used for the complete libawd. ">AWD</a> documents represent any type of camera supported by the format specification. The type of lens is the only required field in the block, and other properties (e.g. type-specific properties) are defined in a numeric attribute list.</p>
<table class="doxtable">
<tr>
<th>Offset </th><th>Size </th><th>Type </th><th>Description  </th></tr>
<tr>
<td>0 </td><td>11 </td><td>BlockHeader </td><td><a class="el" href="awd_specs_2.html#awd_pt2_9_1">Block Header</a> </td></tr>
<tr>
<td>11 </td><td>Variable </td><td>SceneHeader </td><td><a class="el" href="awd_specs_2.html#awd_pt2_12_1">Scene Header</a> </td></tr>
<tr>
<td>Variable </td><td>1 </td><td>bool </td><td>make active(not used for now) </td></tr>
<tr>
<td>Variable </td><td>Variable </td><td>uint16 </td><td>Num of Lists (1 for now) </td></tr>
<tr>
<td>Variable </td><td>Variable </td><td>TypedpropertiesList </td><td>List of properties (used to describe lens)(can be more lists later (cameraController)) </td></tr>
<tr>
<td>Variable </td><td>Variable </td><td>NumAttrList </td><td>Camera-Properties </td></tr>
<tr>
<td>Variable </td><td>Variable </td><td>UserAttrList </td><td>User attributes. </td></tr>
</table>
<p>Table 23: Camera block fields (in addition to common scene object fields.)</p>
<p>Camera-Properties include the Container-Properties.</p>
<p>Lens</p>
<p>A Lens is a typed-property-list.</p>
<table class="doxtable">
<tr>
<th>ID </th><th>Type  </th></tr>
<tr>
<td>5001 </td><td>PerspectiveLensMethod </td></tr>
<tr>
<td>5002 </td><td>OrthographicLensMethod </td></tr>
<tr>
<td>5003 </td><td>OrthographicOffCenterLensMethod </td></tr>
</table>
<p>Table 24: Types of Lenses</p>
<p>PerspectiveLensMethod (methodID = 5001)</p>
<p>ID Name Type Default </p><table class="doxtable">
<tr>
<th>ID </th><th>Name </th><th>Type </th><th>Default  </th></tr>
<tr>
<td>101 </td><td>FOV </td><td>awd_pt2_5_3 </td><td>60 </td></tr>
</table>
<p>OrthographicLensMethod (methodID = 5002)</p>
<table class="doxtable">
<tr>
<th>ID </th><th>Name </th><th>Type </th><th>Default  </th></tr>
<tr>
<td>101 </td><td>Projection Height </td><td>awd_pt2_5_3 </td><td>500 </td></tr>
</table>
<p>OrthographicOffCenterLensMethod (methodID = 5003)</p>
<table class="doxtable">
<tr>
<th>ID </th><th>Name </th><th>Type </th><th>Default  </th></tr>
<tr>
<td>101 </td><td>minX </td><td>awd_pt2_5_3 </td><td>-400 </td></tr>
<tr>
<td>102 </td><td>maxX </td><td>awd_pt2_5_3 </td><td>400 </td></tr>
<tr>
<td>103 </td><td>minY </td><td>awd_pt2_5_3 </td><td>-300 </td></tr>
<tr>
<td>104 </td><td>maxY </td><td>awd_pt2_5_3 </td><td>300 </td></tr>
</table>
<h2><a class="anchor" id="awd_pt2_12_8"></a>
TextureProjector (ID 43)</h2>
<p>Textureprojector is used together with the ProjectiveTextureMethod.</p>
<table class="doxtable">
<tr>
<th>Offset </th><th>Size </th><th>Type </th><th>Description  </th></tr>
<tr>
<td>0 </td><td>11 </td><td>BlockHeader </td><td><a class="el" href="awd_specs_2.html#awd_pt2_9_1">Block Header</a> </td></tr>
<tr>
<td>11 </td><td>Variable </td><td>SceneHeader </td><td><a class="el" href="awd_specs_2.html#awd_pt2_12_1">Scene Header</a> </td></tr>
<tr>
<td>Variable </td><td>4 </td><td><a class="el" href="namespace_a_w_d_1_1_t_y_p_e_s.html#a67050e0d5b2ec92455d9df844eefa24b">AWD::TYPES::BADDR</a> </td><td>The Texture used. </td></tr>
<tr>
<td>Variable </td><td>Variable </td><td>awd_pt2_5_3 </td><td>aspect-ratio </td></tr>
<tr>
<td>Variable </td><td>Variable </td><td>awd_pt2_5_3 </td><td>fov </td></tr>
<tr>
<td>Variable </td><td>Variable </td><td>NumAttrList </td><td>TextureProjectorProperties </td></tr>
<tr>
<td>Variable </td><td>Variable </td><td>UserAttrList </td><td>User attributes. </td></tr>
</table>
<p>Table: TextureProjector block fields (in addition to common scene object fields.)</p>
<h2><a class="anchor" id="awd_pt2_12_9"></a>
LightPicker (ID 51)</h2>
<p>In Away3d a LightPicker tells a material, by which scene-lights it should be lit. A LightPicker-Block in <a class="el" href="namespace_a_w_d.html" title="The namespace used for the complete libawd. ">AWD</a> is made of a name, and a list of AWD-Block-IDs, pointing to Light-Blocks.</p>
<table class="doxtable">
<tr>
<th>Offset </th><th>Size </th><th>Type </th><th>Description  </th></tr>
<tr>
<td>0 </td><td>11 </td><td>BlockHeader </td><td><a class="el" href="awd_specs_2.html#awd_pt2_9_1">Block Header</a> </td></tr>
<tr>
<td>11 </td><td>Variable </td><td>VarString </td><td>Look-up name. </td></tr>
<tr>
<td>Variable </td><td>2 </td><td>uint16 </td><td>Number lights </td></tr>
<tr>
<td>Variable </td><td>Variable </td><td>List of <a class="el" href="namespace_a_w_d_1_1_t_y_p_e_s.html#a67050e0d5b2ec92455d9df844eefa24b">AWD::TYPES::BADDR</a> </td><td>LightIDs </td></tr>
<tr>
<td>Variable </td><td>Variable </td><td>UserAttrList </td><td>User attributes. </td></tr>
</table>
<p>Table 19: MeshInstance fields (in addition to common scene object fields.)</p>
<h1><a class="anchor" id="awd_pt2_13"></a>
Material blocks</h1>
<h2><a class="anchor" id="awd_pt2_13_1"></a>
Material block (ID 81)</h2>
<p>Material blocks represent a Away3D Material.<br />
 The material does not not store any shader code into the <a class="el" href="namespace_a_w_d.html" title="The namespace used for the complete libawd. ">AWD</a> file. <br />
The parser is supposed to create the correct Material based on the material-type.<br />
 In AWD3.0 we use the same material-block to store both materials used for 3D-Geometries and materials used by 2D-Geometries.<br />
 To differ bewteeen this types of materials on import, 3 new material types are added.<br />
 For the usage with by 3d-geometry a AWD-material can have a lot of Material-properties, including Shading-Methods and Effect-Methods.<br />
 For the usage with by 2d-geometry a AWD-material only need to provides the basic information on what texture-atlas area should be used by this material (uv-values).<br />
All other information (color-tranform, filters, depth, mask-depth) will be provided by the Frame-commands on a TimelineFrame.<br />
</p>
<table class="doxtable">
<tr>
<th>Offset </th><th>Size </th><th>Type </th><th>Description  </th></tr>
<tr>
<td>0 </td><td>11 </td><td>BlockHeader </td><td><a class="el" href="awd_specs_2.html#awd_pt2_9_1">Block Header</a> </td></tr>
<tr>
<td>11 </td><td>Variable </td><td>VarString </td><td>Look-up name </td></tr>
<tr>
<td>Variable </td><td>1 </td><td>uint8 </td><td><a class="el" href="awd_specs_2.html#awd_pt2_material_types">Material types</a> </td></tr>
<tr>
<td>Variable </td><td>1 </td><td>uint8 </td><td>Number of <a class="el" href="awd_specs_2.html#awd_pt2_material_shading_methods">Shading Methods</a>. Will always be 0 for materials used by 2D-Geometry </td></tr>
<tr>
<td>Variable </td><td>Variable </td><td>NumAttrList </td><td><a class="el" href="awd_specs_2.html#awd_pt2_material_properties">Material properties</a> </td></tr>
<tr>
<td>Variable </td><td>Variable </td><td>List of ShaderMethod </td><td>List of <a class="el" href="awd_specs_2.html#awd_pt2_material_shading_methods">Shading Methods</a> elements, the length of which is defined by the preceding integer field. </td></tr>
<tr>
<td>Variable </td><td>Variable </td><td>UserAttrList </td><td>Material user attributes. </td></tr>
</table>
<h3><a class="anchor" id="awd_pt2_material_types"></a>
Material types</h3>
<table class="doxtable">
<tr>
<th>Type ID </th><th>Material type  </th></tr>
<tr>
<td>1 </td><td>Color material </td></tr>
<tr>
<td>2 </td><td>Texture material </td></tr>
<tr>
<td>3 </td><td>Fill Color Material (new for AWD3.0 - used for 2D Geometry) - instead of storing the color as uint32, it stores the color as uv-position in texture-atlas </td></tr>
<tr>
<td>4 </td><td>Linear Gradient Material (new for AWD3.0 - used for 2D Geometry) - like Fill Color Material, but two uv-positions are stored. </td></tr>
<tr>
<td>5 </td><td>Radial Gradient Material (new for AWD3.0 - used for 2D Geometry) - like Linear Gradient Material. </td></tr>
</table>
<p>A material can have a addional type-property set in the Material-properties called “spezialID”.<br />
For Materials used by 2D-geometry, this is not used.<br />
 </p><table class="doxtable">
<tr>
<th>spezialID </th><th>Material type  </th></tr>
<tr>
<td>0 (=Default)</td><td>SinglePassMaterial </td></tr>
<tr>
<td>1 </td><td>MultiPassMaterial </td></tr>
</table>
<h3><a class="anchor" id="awd_pt2_material_properties"></a>
Material properties</h3>
<p>This are the properties available for Materials used by 3D-geometry:</p>
<table class="doxtable">
<tr>
<th>ID </th><th>Name </th><th>Type </th><th>ColorMaterial </th><th>MP </th><th>TextureMaterial </th><th>MP </th><th>Description </th><th>Default  </th></tr>
<tr>
<td>1 </td><td>Color </td><td>color </td><td>+</td><td>+</td><td>-</td><td>-</td><td>Color (used only by colormaterials) </td><td>0xffffff </td></tr>
<tr>
<td>2 </td><td>Texture </td><td><a class="el" href="namespace_a_w_d_1_1_t_y_p_e_s.html#a67050e0d5b2ec92455d9df844eefa24b">AWD::TYPES::BADDR</a> </td><td>-</td><td>-</td><td>+</td><td>+</td><td>Reference to texture block (used only by bitmap materials) </td><td>null </td></tr>
<tr>
<td>3 </td><td>NormalTexture </td><td><a class="el" href="namespace_a_w_d_1_1_t_y_p_e_s.html#a67050e0d5b2ec92455d9df844eefa24b">AWD::TYPES::BADDR</a> </td><td>+</td><td>+</td><td>+</td><td>+</td><td>NormalTexture </td><td>null </td></tr>
<tr>
<td>4 </td><td>spezialID </td><td>uint8 </td><td>-</td><td>-</td><td>-</td><td>-</td><td>0: SinglePass 1:MultiPass 2:SkyBox </td><td>0 </td></tr>
<tr>
<td>5 </td><td>smooth </td><td>bool </td><td>+</td><td>+</td><td>+</td><td>+</td><td>Default to true </td><td>true </td></tr>
<tr>
<td>6 </td><td>mipmap </td><td>bool </td><td>+</td><td>+</td><td>+</td><td>+</td><td>Default to true </td><td>true </td></tr>
<tr>
<td>7 </td><td>bothSides </td><td>bool </td><td>+</td><td>+</td><td>+</td><td>+</td><td>Default to false </td><td>false </td></tr>
<tr>
<td>8 </td><td>Pre-multiplied </td><td>bool </td><td>+</td><td>+</td><td>+</td><td>+</td><td>Default to false </td><td>false </td></tr>
<tr>
<td>9 </td><td>BlendMode </td><td>uint8 </td><td>+</td><td>+</td><td>+</td><td>+</td><td>[0:NORMAL,1:ADD,2: ALPHA,8: LAYER,10: MULTIPLY] </td><td>0 </td></tr>
<tr>
<td>10 </td><td>Alpha </td><td>awd_pt2_5_3 </td><td>+</td><td>-</td><td>+</td><td>-</td><td>Overall alpha of material. </td><td>1.0 </td></tr>
<tr>
<td>11 </td><td>Alpha blending </td><td>bool </td><td>+</td><td>-</td><td>+</td><td>-</td><td>Defines whether alpha blending (semi-transparency) should be enabled for this material. </td><td>false </td></tr>
<tr>
<td>12 </td><td>Binary alpha threshold </td><td>awd_pt2_5_3 </td><td>+</td><td>+</td><td>+</td><td>+</td><td>Defines a cut-off threshold for the alpha channel when not using alpha blending. Pixels with alpha over this value will be fully opaque, and all other pixels will be completely transparent. </td><td>0.0 </td></tr>
<tr>
<td>13 </td><td>Repeat </td><td>bool </td><td>+</td><td>+</td><td>+</td><td>+</td><td>Defines whether to repeat this material over the surface of meshes for which the UV coordinates are outside the 0-1 span. </td><td>True </td></tr>
<tr>
<td>14 </td><td>Diffuse Level </td><td>awd_pt2_5_3 </td><td>-</td><td>-</td><td>-</td><td>-</td><td>may be needed in later versions </td><td>1.0 </td></tr>
<tr>
<td>15 </td><td>Ambient level </td><td>awd_pt2_5_3 </td><td>+</td><td>+</td><td>+</td><td>+</td><td>- </td><td>1.0 </td></tr>
<tr>
<td>16 </td><td>Ambient Color </td><td>color </td><td>+</td><td>+</td><td>+</td><td>+</td><td>- </td><td>0xffffff </td></tr>
<tr>
<td>17 </td><td>Ambient texture </td><td><a class="el" href="namespace_a_w_d_1_1_t_y_p_e_s.html#a67050e0d5b2ec92455d9df844eefa24b">AWD::TYPES::BADDR</a> </td><td>-</td><td>-</td><td>+</td><td>+</td><td>- </td><td>null </td></tr>
<tr>
<td>18 </td><td>Specular Level </td><td>awd_pt2_5_3 </td><td>+</td><td>+</td><td>+</td><td>+</td><td>- </td><td>1.0 </td></tr>
<tr>
<td>19 </td><td>Specular Gloss </td><td>awd_pt2_5_3 </td><td>+</td><td>+</td><td>+</td><td>+</td><td>- </td><td>50 </td></tr>
<tr>
<td>20 </td><td>Specular Color </td><td>color </td><td>+</td><td>+</td><td>+</td><td>+</td><td>- </td><td>0xffffff </td></tr>
<tr>
<td>21 </td><td>Specular Texture </td><td><a class="el" href="namespace_a_w_d_1_1_t_y_p_e_s.html#a67050e0d5b2ec92455d9df844eefa24b">AWD::TYPES::BADDR</a> </td><td>+</td><td>+</td><td>+</td><td>+</td><td>- </td><td>null </td></tr>
<tr>
<td>22 </td><td>LightPicker </td><td><a class="el" href="namespace_a_w_d_1_1_t_y_p_e_s.html#a67050e0d5b2ec92455d9df844eefa24b">AWD::TYPES::BADDR</a> </td><td>+</td><td>+</td><td>+</td><td>+</td><td>- </td><td>null </td></tr>
</table>
<p>This are the properties available for Materials used by 2D-geometry:</p>
<table class="doxtable">
<tr>
<th>ID </th><th>Name </th><th>Type </th><th>Description </th><th>Default  </th></tr>
<tr>
<td>1 </td><td>Texture </td><td><a class="el" href="namespace_a_w_d_1_1_t_y_p_e_s.html#a67050e0d5b2ec92455d9df844eefa24b">AWD::TYPES::BADDR</a> </td><td>Reference to texture block (texture-atlas) </td><td>0 </td></tr>
<tr>
<td>2 </td><td>UV-position 1 </td><td><a class="el" href="namespace_a_w_d_1_1_t_y_p_e_s.html#aa814bc19f707275ab0571a3406f1541d">AWD::TYPES::F64</a> </td><td>The uv-position for the first color </td><td>0.0 </td></tr>
<tr>
<td>3 </td><td>UV-position 2 </td><td><a class="el" href="namespace_a_w_d_1_1_t_y_p_e_s.html#aa814bc19f707275ab0571a3406f1541d">AWD::TYPES::F64</a> </td><td>The second uv-position used by gradients </td><td>0.0 </td></tr>
<tr>
<td>4 </td><td>color </td><td>color </td><td>Fallback as long as texture-atlas is not working </td><td>0xffffff </td></tr>
</table>
<h3><a class="anchor" id="awd_pt2_material_shading_methods"></a>
Shading Methods</h3>
<p>A shading method defines a way that a material's surface is rendered, e.g. with regards to light. Some methods require special treatment, e.g. diffuse and specular shading methods, and for this reason shading methods are sorted into different categories. The Base-Method of a Composite-Method must always be parsed before the Composite-Method.</p>
<table class="doxtable">
<tr>
<th>Type ID </th><th>Shading method </th><th>type Category  </th></tr>
<tr>
<td>1 </td><td>EnvMapAmbientMethod </td><td>Ambient </td></tr>
<tr>
<td>51 </td><td>DepthDiffuseMethod (no properties) </td><td>Diffuse </td></tr>
<tr>
<td>52 </td><td>GradientDiffuseMethod </td><td>Diffuse </td></tr>
<tr>
<td>53 </td><td>WrapDiffuseMethod </td><td>Diffuse </td></tr>
<tr>
<td>54 </td><td>LightMapDiffuseMethod </td><td>DiffuseComp </td></tr>
<tr>
<td>55 </td><td>CellDiffuseMethod </td><td>DiffuseComp </td></tr>
<tr>
<td>56 </td><td>SubSurfaceScatteringMethod </td><td>DiffuseComp </td></tr>
<tr>
<td>101 </td><td>AnisotropicSpecularMethod (no properties) </td><td>Specular </td></tr>
<tr>
<td>102 </td><td>PhongSpecularMethod (no properties) </td><td>Specular </td></tr>
<tr>
<td>103 </td><td>CellSpecularMethod </td><td>SpecularComp </td></tr>
<tr>
<td>104 </td><td>FresnelSpecularMethod </td><td>SpecularComp </td></tr>
<tr>
<td>151 </td><td>HeightMapNormalMethod </td><td>Normal </td></tr>
<tr>
<td>152 </td><td>SimpleWaterNormalMethod </td><td>Normal </td></tr>
<tr>
<td>401 </td><td>ColorMatrix </td><td>EffektShader </td></tr>
<tr>
<td>402 </td><td>ColorTransform </td><td>EffektShader </td></tr>
<tr>
<td>403 </td><td>EnvMap </td><td>EffektShader </td></tr>
<tr>
<td>404 </td><td>LightMapMethod </td><td>EffektShader </td></tr>
<tr>
<td>405 </td><td>ProjectiveTextureMethod </td><td>EffektShader </td></tr>
<tr>
<td>406 </td><td>RimLightMethod </td><td>EffektShader </td></tr>
<tr>
<td>407 </td><td>AlphaMaskMethod </td><td>EffektShader </td></tr>
<tr>
<td>408 </td><td>RefractionEnvMapMethod </td><td>EffektShader </td></tr>
<tr>
<td>409 </td><td>OutlineMethod </td><td>EffektShader </td></tr>
<tr>
<td>410 </td><td>FresnelEnvMapMethod </td><td>EffektShader </td></tr>
<tr>
<td>411 </td><td>FogMethod </td><td>EffektShader </td></tr>
<tr>
<td>998 </td><td>ShadowMapMethodBlockMethod </td><td>ShadowMapMethodBlock </td></tr>
<tr>
<td>999 </td><td>EffectMethodBlockMethod </td><td>EffectMethodBlock </td></tr>
</table>
<p>AmbientMethods</p>
<p>EnvMapAmbientMethod (methodID = 1)</p>
<table class="doxtable">
<tr>
<th>ID </th><th>Name </th><th>Type </th><th>Default  </th></tr>
<tr>
<td>1 </td><td>cubeTexture </td><td><a class="el" href="namespace_a_w_d_1_1_t_y_p_e_s.html#a67050e0d5b2ec92455d9df844eefa24b">AWD::TYPES::BADDR</a> </td><td>defaultTexture </td></tr>
</table>
<p>DiffuseMethods</p>
<p>GradientDiffuseMethod (methodID = 52)</p>
<table class="doxtable">
<tr>
<th>ID </th><th>Name </th><th>Type </th><th>Default  </th></tr>
<tr>
<td>1 </td><td>gradient-texture </td><td><a class="el" href="namespace_a_w_d_1_1_t_y_p_e_s.html#a67050e0d5b2ec92455d9df844eefa24b">AWD::TYPES::BADDR</a> </td><td>defaultTexture </td></tr>
</table>
<p>WrapDiffuseMethod (methodID = 53)</p>
<table class="doxtable">
<tr>
<th>ID </th><th>Name </th><th>Type </th><th>Default  </th></tr>
<tr>
<td>101 </td><td>warp factor </td><td>awd_pt2_5_3 </td><td>0.5 </td></tr>
</table>
<p>LightMapDiffuseMethod (methodID = 54)</p>
<table class="doxtable">
<tr>
<th>ID </th><th>Name </th><th>Type </th><th>Default  </th></tr>
<tr>
<td>401 </td><td>blendMode </td><td>uint8 </td><td>MULTIPLY options: add / multiply </td></tr>
<tr>
<td>1 </td><td>lightMap-texture </td><td><a class="el" href="namespace_a_w_d_1_1_t_y_p_e_s.html#a67050e0d5b2ec92455d9df844eefa24b">AWD::TYPES::BADDR</a> </td><td>defaultTexture </td></tr>
</table>
<p>CellDiffuseMethod (methodID = 55)</p>
<table class="doxtable">
<tr>
<th>ID </th><th>Name </th><th>Type </th><th>Default  </th></tr>
<tr>
<td>401 </td><td>levels </td><td>uint8 </td><td>3 </td></tr>
<tr>
<td>101 </td><td>smoothness </td><td>awd_pt2_5_3 </td><td>0.1 </td></tr>
</table>
<p>SubsurfaceScatteringDiffuseMethod (methodID = 56) - not implemented in AwayBuilder atm</p>
<table class="doxtable">
<tr>
<th>ID </th><th>Name </th><th>Type </th><th>Default  </th></tr>
<tr>
<td>101 </td><td>Scattering </td><td>awd_pt2_5_3 </td><td>0.2 </td></tr>
<tr>
<td>102 </td><td>Translucency </td><td>awd_pt2_5_3 </td><td>1 </td></tr>
<tr>
<td>601 </td><td>Scatter Color </td><td>Color </td><td>0xFFFFFF </td></tr>
</table>
<p>SpecularMethods</p>
<p>CellSpecularMethod (methodID = 103)</p>
<table class="doxtable">
<tr>
<th>ID </th><th>Name </th><th>Type </th><th>Default  </th></tr>
<tr>
<td>101 </td><td>cut-off </td><td>awd_pt2_5_3 </td><td>0.5 </td></tr>
<tr>
<td>102 </td><td>smoothness </td><td>awd_pt2_5_3 </td><td>0.1 </td></tr>
</table>
<p>FresnelSpecularMethod (methodID = 104)</p>
<table class="doxtable">
<tr>
<th>ID </th><th>Name </th><th>Type </th><th>Default  </th></tr>
<tr>
<td>701 </td><td>BasedOnSurface </td><td>bool </td><td>true </td></tr>
<tr>
<td>101 </td><td>power </td><td>awd_pt2_5_3 </td><td>5 </td></tr>
<tr>
<td>102 </td><td>Reflectance </td><td>awd_pt2_5_3 </td><td>0.1 </td></tr>
</table>
<p>NormalMethods</p>
<p>HeightMapNormalMethod (methodID = 151) - not available in AwayBuilder atm</p>
<table class="doxtable">
<tr>
<th>ID </th><th>Name </th><th>Type </th><th>Default  </th></tr>
<tr>
<td>101 </td><td>World width </td><td>awd_pt2_5_3 </td><td>5 </td></tr>
<tr>
<td>102 </td><td>World height </td><td>awd_pt2_5_3 </td><td>5 </td></tr>
<tr>
<td>103 </td><td>World depth </td><td>awd_pt2_5_3 </td><td>5 </td></tr>
</table>
<p>SimpleWaterNormalMethod (methodID = 152)</p>
<table class="doxtable">
<tr>
<th>ID </th><th>Name </th><th>Type </th><th>Default  </th></tr>
<tr>
<td>1 </td><td>Second Normal map </td><td><a class="el" href="namespace_a_w_d_1_1_t_y_p_e_s.html#a67050e0d5b2ec92455d9df844eefa24b">AWD::TYPES::BADDR</a> </td><td>defaultTexture </td></tr>
</table>
<h3>ShadowMapMethods / EffectMethods</h3>
<p>ShadowMapMethodBlockMethod (methodID = 52) / EffectMethodBlockMethod (methodID = 52)</p>
<table class="doxtable">
<tr>
<th>ID </th><th>Name </th><th>Type </th><th>Default  </th></tr>
<tr>
<td>1 </td><td>TargetBlock </td><td><a class="el" href="namespace_a_w_d_1_1_t_y_p_e_s.html#a67050e0d5b2ec92455d9df844eefa24b">AWD::TYPES::BADDR</a> </td><td>defaultTexture The id of the MethodBlock </td></tr>
</table>
<h2><a class="anchor" id="awd_pt2_13_2"></a>
BitmapTexture block (ID 82)</h2>
<p>The bitmap texture block defines a bitmap, either as an external file or as embedded image data, that can be referenced and used by other blocks.</p>
<table class="doxtable">
<tr>
<th>Offset </th><th>Size </th><th>Type </th><th>Description  </th></tr>
<tr>
<td>0 </td><td>11 </td><td>BlockHeader </td><td><a class="el" href="awd_specs_2.html#awd_pt2_9_1">Block Header</a> </td></tr>
<tr>
<td>11 </td><td>Variable </td><td>VarString </td><td>Look-up name </td></tr>
<tr>
<td>Variable </td><td>1 </td><td>uint8 </td><td>Image type 0: External 1: Embedded </td></tr>
<tr>
<td>Variable </td><td>4 </td><td><a class="el" href="namespace_a_w_d_1_1_t_y_p_e_s.html#a0633e60becfa73b1f2e7681b000314c0">AWD::TYPES::UINT32</a> </td><td>Data length </td></tr>
<tr>
<td>Variable </td><td>Variable </td><td>ByteArray or ConstString </td><td>Image data (JPEG/PNG/ATF-file stream) or URL to external file. </td></tr>
<tr>
<td>Variable </td><td>Variable </td><td>NumAttrList </td><td>Texture properties (none in this version.) </td></tr>
<tr>
<td>Variable </td><td>Variable </td><td>UserAttrList </td><td>Texture user attributes. </td></tr>
</table>
<p>Table 27: Texture block fields</p>
<h2><a class="anchor" id="awd_pt2_13_3"></a>
CubeTexture block (ID 83)</h2>
<table class="doxtable">
<tr>
<th>Offset </th><th>Size </th><th>Type </th><th>Description  </th></tr>
<tr>
<td>0 </td><td>11 </td><td>BlockHeader </td><td><a class="el" href="awd_specs_2.html#awd_pt2_9_1">Block Header</a> </td></tr>
<tr>
<td>11 </td><td>1 </td><td>unit8 </td><td>0: external 1: embed </td></tr>
<tr>
<td>12 </td><td>Variable </td><td>VarString </td><td>Look-up name </td></tr>
<tr>
<td>Variable </td><td>Variable </td><td>ByteArray or ConstString </td><td>Image data (JPEG/PNG/ATF-file stream) or URL to external file. </td></tr>
<tr>
<td>Variable </td><td>Variable </td><td>ByteArray or ConstString </td><td>Image data (JPEG/PNG/ATF-file stream) or URL to external file. </td></tr>
<tr>
<td>Variable </td><td>Variable </td><td>ByteArray or ConstString </td><td>Image data (JPEG/PNG/ATF-file stream) or URL to external file. </td></tr>
<tr>
<td>Variable </td><td>Variable </td><td>ByteArray or ConstString </td><td>Image data (JPEG/PNG/ATF-file stream) or URL to external file. </td></tr>
<tr>
<td>Variable </td><td>Variable </td><td>ByteArray or ConstString </td><td>Image data (JPEG/PNG/ATF-file stream) or URL to external file. </td></tr>
<tr>
<td>Variable </td><td>Variable </td><td>ByteArray or ConstString </td><td>Image data (JPEG/PNG/ATF-file stream) or URL to external file. </td></tr>
<tr>
<td>Variable </td><td>Variable </td><td>NumAttrList </td><td>CubeTexture properties (none) </td></tr>
<tr>
<td>Variable </td><td>Variable </td><td>UserAttrList </td><td>CubeTexture user attributes. </td></tr>
</table>
<p>Table 28: CubeTexture block fields</p>
<h2><a class="anchor" id="awd_pt2_13_4"></a>
SharedMethod-Block(ID 91)</h2>
<p>A Shared Method is a Block that contains a Method that can be shared between multiple materials. In the AWD-Block-Structure it must appear before any materials that is using it.</p>
<table class="doxtable">
<tr>
<th>Offset </th><th>Size </th><th>Type </th><th>Description  </th></tr>
<tr>
<td>0 </td><td>11 </td><td>BlockHeader </td><td><a class="el" href="awd_specs_2.html#awd_pt2_9_1">Block Header</a> </td></tr>
<tr>
<td>11 </td><td>Variable </td><td>VarString </td><td>Look-up name. </td></tr>
<tr>
<td>Variable </td><td>Variable </td><td>NumAttrList </td><td>Method </td></tr>
<tr>
<td>Variable </td><td>Variable </td><td>UserAttrList </td><td>User attributes. </td></tr>
</table>
<p>Table 18: Container block fields (in addition to common scene object fields).</p>
<h2><a class="anchor" id="awd_pt2_13_5"></a>
EffectMethods</h2>
<p>EffectMethods are stored in SharedMethod-Blocks, so they can be accessed by multiple Materials.</p>
<p>ColorMatrixMethod (methodID = 401)</p>
<table class="doxtable">
<tr>
<th>ID </th><th>Name </th><th>Type </th><th>Default  </th></tr>
<tr>
<td>801 </td><td>matrix </td><td>ConstList of awd_pt2_5_3 </td><td>default = identity matrix </td></tr>
</table>
<p>ColorTransformMethod (methodID = 402)</p>
<table class="doxtable">
<tr>
<th>ID </th><th>Name </th><th>Type </th><th>Default  </th></tr>
<tr>
<td>101 </td><td>alphaMultiplier </td><td>awd_pt2_5_3 </td><td>1 </td></tr>
<tr>
<td>102 </td><td>redMultiplier </td><td>awd_pt2_5_3 </td><td>1 </td></tr>
<tr>
<td>103 </td><td>greenMultiplier </td><td>awd_pt2_5_3 </td><td>1 </td></tr>
<tr>
<td>104 </td><td>blueMultiplier </td><td>awd_pt2_5_3 </td><td>1 </td></tr>
<tr>
<td>601 </td><td>colorOffset </td><td>color </td><td>0x00000000 </td></tr>
</table>
<p>EnvMapMethod (methodID = 403)</p>
<table class="doxtable">
<tr>
<th>ID </th><th>Name </th><th>Type </th><th>Default  </th></tr>
<tr>
<td>1 </td><td>cubeTexture </td><td><a class="el" href="namespace_a_w_d_1_1_t_y_p_e_s.html#a67050e0d5b2ec92455d9df844eefa24b">AWD::TYPES::BADDR</a> </td><td>DefaultCubeTexture </td></tr>
<tr>
<td>101 </td><td>alpha </td><td>awd_pt2_5_3 </td><td>1 </td></tr>
<tr>
<td>2 </td><td>mask </td><td><a class="el" href="namespace_a_w_d_1_1_t_y_p_e_s.html#a67050e0d5b2ec92455d9df844eefa24b">AWD::TYPES::BADDR</a> </td><td>Default-Texture </td></tr>
</table>
<p>LightMapMethod (methodID = 404)</p>
<table class="doxtable">
<tr>
<th>ID </th><th>Name </th><th>Type </th><th>Default  </th></tr>
<tr>
<td>401 </td><td>blendMode </td><td>uint8 </td><td>default MULTIPLY(10) / other option= ADD(1) </td></tr>
<tr>
<td>1 </td><td>texture </td><td><a class="el" href="namespace_a_w_d_1_1_t_y_p_e_s.html#a67050e0d5b2ec92455d9df844eefa24b">AWD::TYPES::BADDR</a> </td><td>Default_Texture </td></tr>
</table>
<p>ProjectiveTextureMethod (methodID = 405)</p>
<table class="doxtable">
<tr>
<th>ID </th><th>Name </th><th>Type </th><th>Default  </th></tr>
<tr>
<td>401 </td><td>mode </td><td>uint8 </td><td>Default=MULTIPLY options: ADD MIX </td></tr>
<tr>
<td>1 </td><td>textureProjector </td><td><a class="el" href="namespace_a_w_d_1_1_t_y_p_e_s.html#a67050e0d5b2ec92455d9df844eefa24b">AWD::TYPES::BADDR</a> </td><td>default = null </td></tr>
</table>
<p>RimLightMethod (methodID = 406)</p>
<table class="doxtable">
<tr>
<th>ID </th><th>Name </th><th>Type </th><th>Default  </th></tr>
<tr>
<td>601 </td><td>color </td><td>color </td><td>0xffffff </td></tr>
<tr>
<td>101 </td><td>Strength </td><td>awd_pt2_5_3 </td><td>0.4 </td></tr>
<tr>
<td>102 </td><td>power </td><td>awd_pt2_5_3 </td><td>2 </td></tr>
</table>
<p>AlphaMaskMethod (methodID = 407)</p>
<table class="doxtable">
<tr>
<th>ID </th><th>Name </th><th>Type </th><th>Default  </th></tr>
<tr>
<td>701 </td><td>UseSecondaryUV </td><td>bool </td><td>false </td></tr>
<tr>
<td>1 </td><td>texture </td><td><a class="el" href="namespace_a_w_d_1_1_t_y_p_e_s.html#a67050e0d5b2ec92455d9df844eefa24b">AWD::TYPES::BADDR</a> </td><td>Default_texture </td></tr>
</table>
<p>RefractionEnvMapMethod (methodID = 408)</p>
<table class="doxtable">
<tr>
<th>ID </th><th>Name </th><th>Type </th><th>Default  </th></tr>
<tr>
<td>1 </td><td>envMap(CubeTexture) </td><td><a class="el" href="namespace_a_w_d_1_1_t_y_p_e_s.html#a67050e0d5b2ec92455d9df844eefa24b">AWD::TYPES::BADDR</a> </td><td>Default_Cube_texture </td></tr>
<tr>
<td>101 </td><td>RefractionIndex </td><td>awd_pt2_5_3 </td><td>0.1 </td></tr>
<tr>
<td>102 </td><td>Dispersion R </td><td>awd_pt2_5_3 </td><td>0.01 </td></tr>
<tr>
<td>103 </td><td>Dispersion G </td><td>awd_pt2_5_3 </td><td>0.01 </td></tr>
<tr>
<td>104 </td><td>Dispersion B </td><td>awd_pt2_5_3 </td><td>0.01 </td></tr>
<tr>
<td>105 </td><td>Alpha </td><td>awd_pt2_5_3 </td><td>1 </td></tr>
</table>
<p>OutlineMethod (methodID = 409)</p>
<table class="doxtable">
<tr>
<th>ID </th><th>Name </th><th>Type </th><th>Default  </th></tr>
<tr>
<td>601 </td><td>OutlineColor </td><td>color </td><td>0x00000000 </td></tr>
<tr>
<td>101 </td><td>OutlineSize </td><td>awd_pt2_5_3 </td><td>1 </td></tr>
<tr>
<td>701 </td><td>ShowInnerLines </td><td>bool </td><td>true </td></tr>
<tr>
<td>702 </td><td>DedicatedMesh </td><td>bool </td><td>false </td></tr>
</table>
<p>FresnelEnvMapMethod (methodID = 410)</p>
<table class="doxtable">
<tr>
<th>ID </th><th>Name </th><th>Type </th><th>Default  </th></tr>
<tr>
<td>1 </td><td>envMap </td><td><a class="el" href="namespace_a_w_d_1_1_t_y_p_e_s.html#a67050e0d5b2ec92455d9df844eefa24b">AWD::TYPES::BADDR</a> </td><td>Default_Cube_Texture </td></tr>
<tr>
<td>101 </td><td>alpha </td><td>awd_pt2_5_3 </td><td>1 </td></tr>
</table>
<p>FogMethod (methodID = 411)</p>
<table class="doxtable">
<tr>
<th>ID </th><th>Name </th><th>Type </th><th>Default  </th></tr>
<tr>
<td>101 </td><td>Min-Distance </td><td>awd_pt2_5_3 </td><td>0 </td></tr>
<tr>
<td>102 </td><td>Max-Distance </td><td>awd_pt2_5_3 </td><td>1000 </td></tr>
<tr>
<td>601 </td><td>Color </td><td>color </td><td>0x808080 </td></tr>
</table>
<h2><a class="anchor" id="awd_pt2_13_6"></a>
EffectMethodsShadowMapMethod-Block (ID 92)</h2>
<p>A ShadowMap is a Block that contains a ShadowMapMethod, and the AWD-ID (for the light it should be applied to). In the AWD-Block-Structure it must appear after the associated Light-Block, and before any Material-Block that is using it.</p>
<table class="doxtable">
<tr>
<th>Offset </th><th>Size </th><th>Type </th><th>Description  </th></tr>
<tr>
<td>0 </td><td>11 </td><td>BlockHeader </td><td><a class="el" href="awd_specs_2.html#awd_pt2_9_1">Block Header</a> </td></tr>
<tr>
<td>11 </td><td>Variable </td><td>VarString </td><td>Look-up name. </td></tr>
<tr>
<td>Variable </td><td>32 </td><td>Block-Address </td><td>LightID </td></tr>
<tr>
<td>Variable </td><td>Variable </td><td>NumAttrList </td><td>Method </td></tr>
<tr>
<td>Variable </td><td>Variable </td><td>UserAttrList </td><td>User attributes. </td></tr>
</table>
<p>Table 18: Container block fields (in addition to common scene object fields).</p>
<p>ShadowMapMethods</p>
<p>Type ID ShadowMapMethod Type Category </p><table class="doxtable">
<tr>
<th>ID </th><th>ShadowMapMethod </th><th>Type Category  </th></tr>
<tr>
<td>1001 </td><td>CascadeShadowMapMethod </td><td>Composite-Method </td></tr>
<tr>
<td>1002 </td><td>NearShadowMapMethod </td><td>Composite-Method </td></tr>
<tr>
<td>1101 </td><td>FilteredShadowMapMethod </td><td>Methods </td></tr>
<tr>
<td>1102 </td><td>DitheredShadowMapMethod </td><td>Methods </td></tr>
<tr>
<td>1103 </td><td>SoftShadowMapMethod </td><td>Methods </td></tr>
<tr>
<td>1104 </td><td>HardShadowMapMethod </td><td>Methods </td></tr>
</table>
<p>CascadeShadowMapMethod (methodID = 1001) </p><table class="doxtable">
<tr>
<th>ID </th><th>Name </th><th>Type </th><th>Default  </th></tr>
<tr>
<td>1 </td><td>baseMethod </td><td>Method </td><td>ShadowMapMethodBase (?) </td></tr>
</table>
<p>NearShadowMapMethod (methodID = 1002) </p><table class="doxtable">
<tr>
<th>ID </th><th>Name </th><th>Type </th><th>Default  </th></tr>
<tr>
<td>1 </td><td>baseMethod </td><td>Method </td><td>ShadowMapMethodBase (?) </td></tr>
</table>
<p>FilteredShadowMapMethod (methodID = 1101) </p><table class="doxtable">
<tr>
<th>ID </th><th>Name </th><th>Type </th><th>Default  </th></tr>
<tr>
<td>101 </td><td>Alpha </td><td>awd_pt2_5_3 </td><td>1.0 </td></tr>
<tr>
<td>102 </td><td>Epsilon </td><td>awd_pt2_5_3 </td><td>0.002 </td></tr>
</table>
<p>DitheredShadowMapMethod (methodID = 1102) </p><table class="doxtable">
<tr>
<th>ID </th><th>Name </th><th>Type </th><th>Default  </th></tr>
<tr>
<td>101 </td><td>Alpha </td><td>awd_pt2_5_3 </td><td>1 </td></tr>
<tr>
<td>102 </td><td>Epsilon </td><td>awd_pt2_5_3 </td><td>0.002 </td></tr>
<tr>
<td>201 </td><td>Samples </td><td>awd_pt2_5_3 </td><td>5 </td></tr>
<tr>
<td>103 </td><td>Range </td><td>awd_pt2_5_3 </td><td>1 </td></tr>
</table>
<p>SoftShadowMapMethod (methodID = 1103) </p><table class="doxtable">
<tr>
<th>ID </th><th>Name </th><th>Type </th><th>Default  </th></tr>
<tr>
<td>101 </td><td>Alpha </td><td>awd_pt2_5_3 </td><td>1 </td></tr>
<tr>
<td>102 </td><td>Epsilon </td><td>awd_pt2_5_3 </td><td>0.002 </td></tr>
<tr>
<td>201 </td><td>Samples </td><td>awd_pt2_5_3 </td><td>5 </td></tr>
<tr>
<td>103 </td><td>Range </td><td>awd_pt2_5_3 </td><td>1 </td></tr>
</table>
<p>HardShadowMapMethod (methodID = 1104)</p>
<table class="doxtable">
<tr>
<th>ID </th><th>Name </th><th>Type </th><th>Default  </th></tr>
<tr>
<td>101 </td><td>Alpha </td><td>awd_pt2_5_3 </td><td>1 </td></tr>
<tr>
<td>102 </td><td>Epsilon </td><td>awd_pt2_5_3 </td><td>0.002 </td></tr>
</table>
<h1><a class="anchor" id="awd_pt2_14"></a>
Animation blocks</h1>
<h2><a class="anchor" id="awd_pt2_14_1"></a>
Skeleton (ID 101)</h2>
<p>The Skeleton block defines a skeletal hierarchy of joints that can be bound to by any mesh (see the MeshData block for details on how to bind a mesh to a skeleton.)</p>
<table class="doxtable">
<tr>
<th>Offset </th><th>Size </th><th>Type </th><th>Description  </th></tr>
<tr>
<td>0 </td><td>11 </td><td>BlockHeader </td><td><a class="el" href="awd_specs_2.html#awd_pt2_9_1">Block Header</a> </td></tr>
<tr>
<td>0 </td><td>Variable </td><td>VarString </td><td>Look-up name </td></tr>
<tr>
<td>Variable </td><td>2 </td><td>uint16 </td><td>Number of joints </td></tr>
<tr>
<td>Variable </td><td>Variable </td><td>NumAttrList </td><td>Skeleton properties (none in this version.) </td></tr>
<tr>
<td>Variable </td><td>Variable </td><td>List of SkeletonJoint </td><td>A list of joints </td></tr>
<tr>
<td>Variable </td><td>Variable </td><td>UserAttrList </td><td>Skeleton user attributes. </td></tr>
</table>
<p>Table 30: Structure of a skeleton block.</p>
<p>The skeleton block contains a list of joints which are the "bones" in the skeleton. The internal structure of a joint in <a class="el" href="namespace_a_w_d.html" title="The namespace used for the complete libawd. ">AWD</a> is defined by the next section. There can be virtually any number of joints (limited only by the 16-bit integer defining the number) in a skeleton block, but the receiving engine might have harder restrictions on how many joints it can handle.</p>
<h3><a class="anchor" id="awd_pt2_14_1_1"></a>
Skeleton joint</h3>
<p>The skeleton joint defines a deformable and bindable "bone" in the skeletal hierarchy. The data inside a joint structure defines it's name and parent-child relationships, as well as the "bind" transform, which describes the transformational state that the joint should be in when vertices are bound to it.</p>
<table class="doxtable">
<tr>
<th>Offset </th><th>Size </th><th>Type </th><th>Description  </th></tr>
<tr>
<td>0 </td><td>2 </td><td>uint16 </td><td>Joint ID </td></tr>
<tr>
<td>4 </td><td>2 </td><td>uint16 </td><td>Parent joint ID </td></tr>
<tr>
<td>Variable </td><td>Variable </td><td>VarString </td><td>Look-up name </td></tr>
<tr>
<td>Variable </td><td>Variable </td><td>Matrix4x3 </td><td>Bind pose transform </td></tr>
<tr>
<td>Variable </td><td>Variable </td><td>NumAttrList </td><td>Joint properties (none in this version.) </td></tr>
<tr>
<td>Variable </td><td>Variable </td><td>UserAttrList </td><td>Joint user attributes. </td></tr>
</table>
<p>Table 31: Structure of joints inside a skeleton block</p>
<p>Each joint has an ID, which among other things is used by other joints to define the parent joint. A parent joint ID of -1 means there is no parent, i.e. that the defining joint is the root. The joint ID is also used to reference a particular joint from the joint index data stream in geometry blocks for binding.</p>
<h2><a class="anchor" id="awd_pt2_14_2"></a>
SkeletonPose (ID 102)</h2>
<p>The skeleton pose block defines the transformations for all bones in a skeleton such that the skeleton assumes a particular static pose. These can then be used to position a mesh (e.g. a character) statically, or in a frame-by-frame animation using a SkeletonAnimation block (see the next section.) A pose comprises a list of joint transform structures, which in turn define the transformation for each of the joints in the skeleton. It also defines the length of said list, and a name. There is no hard binding between a skeleton pose and a particular skeleton. It's up to the logic of the parsing party (e.g. a game engine) to apply the pose to a compatible skeleton. This allows for the same poses (and hence animations) to be used for several different skeletons, as long as they have the same structure. The below table defines the structure of the SkeletonPose block.</p>
<table class="doxtable">
<tr>
<th>Offset </th><th>Size </th><th>Type </th><th>Description  </th></tr>
<tr>
<td>0 </td><td>11 </td><td>BlockHeader </td><td><a class="el" href="awd_specs_2.html#awd_pt2_9_1">Block Header</a> </td></tr>
<tr>
<td>0 </td><td>Variable </td><td>VarString </td><td>Look-up name </td></tr>
<tr>
<td>Variable </td><td>2 </td><td>uint16 </td><td>Number of joint transformations </td></tr>
<tr>
<td>Variable </td><td>Variable </td><td>NumAttrList </td><td>Pose properties (none in this version.) </td></tr>
<tr>
<td>Variable </td><td>Variable </td><td>List of JointTransform </td><td>A list of joint transformations </td></tr>
<tr>
<td>Variable </td><td>Variable </td><td>UserAttrList </td><td>Pose user attributes. </td></tr>
</table>
<p>Table 32: Structure of SkeletonPose block.</p>
<h3><a class="anchor" id="awd_pt2_14_2_1"></a>
Skeleton pose joint transform</h3>
<p>The joint transform element, a list of which is contained within the skeleton pose block, comprises a transform matrix for a single joint. The order of the joint transform elements within the pose block should be the same as the order of the joint elements in the skeleton block, that is depth-first incrementally recursive. The first field of the joint transform element is a boolean which indicates whether there is a transformation defined for the joint represented by this element. If true, the next field is a 4x4 matrix. If false, there is no second field and the next piece of data will be the next joint transform (if any.)</p>
<table class="doxtable">
<tr>
<th>Offset </th><th>Size </th><th>Type </th><th>Description  </th></tr>
<tr>
<td>0 </td><td>1 </td><td>bool </td><td>Defines whether joint has transformation </td></tr>
<tr>
<td>1 </td><td>Variable </td><td>Matrix4x3 </td><td>Transformation for joint (if any) </td></tr>
</table>
<p>Table 33: Structure of a joint transform element inside a SkeletonPose block.</p>
<h2><a class="anchor" id="awd_pt2_14_3"></a>
SkeletonAnimation (ID 103)</h2>
<p>Skeleton animation blocks define actual animation of a skeleton as frame-by-frame poses. The term "frame" is used for a point in time at which an exact pose is defined in the file format. It does not necessarily coincide with a refresh in the playback engine. Instead, these frames should be regarded as keyframes, and the actual output during playback be calculated by interpolating two subsequent keyframes.</p>
<table class="doxtable">
<tr>
<th>Offset </th><th>Size </th><th>Type </th><th>Description  </th></tr>
<tr>
<td>0 </td><td>11 </td><td>BlockHeader </td><td><a class="el" href="awd_specs_2.html#awd_pt2_9_1">Block Header</a> </td></tr>
<tr>
<td>0 </td><td>Variable </td><td>VarString </td><td>Look-up name </td></tr>
<tr>
<td>Variable </td><td>2 </td><td>uint16 </td><td>Number of frames </td></tr>
<tr>
<td>Variable </td><td>Variable </td><td>NumAttrList </td><td>Animation properties (none in this version.) </td></tr>
<tr>
<td>Variable </td><td>Variable </td><td>List of SkelAnimFrame </td><td>Frames as a list of skeleton animation frame structures (see below.) </td></tr>
<tr>
<td>Variable </td><td>Variable </td><td>UserAttrList </td><td>Animation user attributes. </td></tr>
</table>
<p>Table 34: Structure of SkeletonAnimation blocks.</p>
<h3><a class="anchor" id="awd_pt2_14_3_1"></a>
Skeleton animation frames</h3>
<p>The frames in a skeleton animation are defined in a list of skeleton animation frame structures, which are explained in the structure table below. They consist of a reference to a skeleton pose block, as well as a duration in milliseconds for that frame. This allows for variable-duration frames, which would typically be interpolated between by the animation engine.</p>
<table class="doxtable">
<tr>
<th>Offset </th><th>Size </th><th>Type </th><th>Description  </th></tr>
<tr>
<td>0 </td><td>4 </td><td><a class="el" href="namespace_a_w_d_1_1_t_y_p_e_s.html#a67050e0d5b2ec92455d9df844eefa24b">AWD::TYPES::BADDR</a> </td><td>ID of skeleton pose block. </td></tr>
<tr>
<td>4 </td><td>2 </td><td>uint16 </td><td>Duration in milliseconds </td></tr>
</table>
<p>Table 35: Structure of SkelAnimFrame elements.</p>
<h2><a class="anchor" id="awd_pt2_14_4"></a>
MeshPose (ID 111) / MeshPoseAnimation (ID 112)</h2>
<p>The MeshPose block defines the Vertex- Animation state of a Geometry . The MeshPoseAnimationBlock is similar to the MeshPose-Block. The only difference is, that, it contains a addional list of Animation-States and a additional UINT16 ( Number Of Frames/lenght of the addional list +1).</p>
<table class="doxtable">
<tr>
<th>Offset </th><th>Size </th><th>Type </th><th>Description  </th></tr>
<tr>
<td>0 </td><td>Variable </td><td>VarString </td><td>Look-up name </td></tr>
<tr>
<td>Variable </td><td>4 </td><td><a class="el" href="namespace_a_w_d_1_1_t_y_p_e_s.html#a67050e0d5b2ec92455d9df844eefa24b">AWD::TYPES::BADDR</a> </td><td>targetGeometryID </td></tr>
<tr>
<td>Variable </td><td>2 </td><td>uint16 </td><td>Number of Frames </td></tr>
<tr>
<td>Variable </td><td>2 </td><td>uint16 </td><td>Number of Subgeometries </td></tr>
<tr>
<td>Variable </td><td>2 </td><td>uint16 </td><td>number of streams </td></tr>
<tr>
<td>Variable </td><td>2*number of streams </td><td>uint16 </td><td>types of streams </td></tr>
<tr>
<td>Variable </td><td>Variable </td><td>NumAttrList </td><td>Mesh-Animation properties </td></tr>
<tr>
<td>Variable </td><td>Variable </td><td>AnimationState </td><td>Mesh-Animation-State </td></tr>
<tr>
<td>Variable </td><td>Variable </td><td>AnimationStateList </td><td>List of addional´Mesh-Animation-States </td></tr>
<tr>
<td>Variable </td><td>Variable </td><td>UserAttrList </td><td>Animation user attributes. </td></tr>
</table>
<p>Table 34: Structure of MeshPose / MeshPoseAnimation Blocks.</p>
<p>Mesh Animation Properties</p>
<p>All Mesh-Animation-properties are optional, so we have a minimal fileSize for the MeshAnimations with default settings. (you might want to overwrite the settings by code later anyway).</p>
<table class="doxtable">
<tr>
<th>ID </th><th>Name </th><th>Type </th><th>Default  </th></tr>
<tr>
<td>1 </td><td>Loop </td><td>bool </td><td>true </td></tr>
<tr>
<td>2 </td><td>StitchFinalFrame </td><td>bool </td><td>false </td></tr>
<tr>
<td>3 </td><td>useTranlation </td><td>bool </td><td>false </td></tr>
<tr>
<td>4 </td><td>absolutePositions </td><td>bool </td><td>true </td></tr>
<tr>
<td>5 </td><td>parsingStyle </td><td>uint16 </td><td>Default = 0 </td></tr>
</table>
<p>0: all verticles saved 1: use vertOffset 2: vector3D + <a class="el" href="namespace_a_w_d_1_1_t_y_p_e_s.html#a0633e60becfa73b1f2e7681b000314c0">AWD::TYPES::UINT32</a> 6 vertOffset List of <a class="el" href="namespace_a_w_d_1_1_t_y_p_e_s.html#a0633e60becfa73b1f2e7681b000314c0">AWD::TYPES::UINT32</a> 0 (can be used if the encoder orders verticles by unMorphed/Morphed)</p>
<p>must be set for each subgeometry</p>
<p>7 parsingStyleFrame bool Default = false. If true, the parsingStyle-property is expected to be written in every frame</p>
<p>Mesh Animation State</p>
<p>The Length of Stream and the List of Vertex-position are repeated for each SubGeometry.</p>
<table class="doxtable">
<tr>
<th>Offset </th><th>Size </th><th>Type </th><th>Description  </th></tr>
<tr>
<td>0 </td><td>2 </td><td>uint16 </td><td>Frame Duration </td></tr>
<tr>
<td>2 (optional)</td><td>2 </td><td>uint16 </td><td>ParsingStyle This is only set when “parsingStyleFrame” is true ! </td></tr>
<tr>
<td>variable </td><td>4 </td><td><a class="el" href="namespace_a_w_d_1_1_t_y_p_e_s.html#a0633e60becfa73b1f2e7681b000314c0">AWD::TYPES::UINT32</a> </td><td>Length of all Streams together </td></tr>
<tr>
<td>Variable </td><td>Variable </td><td>variable </td><td>All Streams </td></tr>
</table>
<pre class="fragment">ID      |         Stream        |        Type           
</pre><p> ---------&mdash;|--------------------&mdash;|----------------&mdash; 1 |Vertex positions |(float32) 2 | Vertex positions |(float64) 3 | Original-Indicies (see parsingStyle 2)| 4 | UV coordinates (not used yet)| (float32) 5 |UV coordinates (not used yet)| (float64) 6 |Vertex normals (not used yet) |(float32) 7 |Vertex normals (not used yet) |(float64)</p>
<p>Streamdata</p>
<p>The Number of Streams and theire Types are defined by the MeshPoseAnimationBlock, because they should be the same for each frame.</p>
<table class="doxtable">
<tr>
<th>Offset </th><th>Size </th><th>Type </th><th>Description  </th></tr>
<tr>
<td>0 </td><td>2 </td><td><a class="el" href="namespace_a_w_d_1_1_t_y_p_e_s.html#a0633e60becfa73b1f2e7681b000314c0">AWD::TYPES::UINT32</a> </td><td>Length of Stream </td></tr>
<tr>
<td>4 </td><td>variable </td><td>variable </td><td>StreamData </td></tr>
</table>
<p>Parsing Style</p>
<p>The ParsingStyle tells the Parser how the StreamData of the Streams have to be interpreted.</p>
<p>By setting the MeshPoseBlock-property “parsingStyleFrame” to True, the parsingStyle is not expected to be the same for all frames. If “parsingStyleFrame” is False, the parsingStyle will not be written in the MeshAnimationState (the frames).</p>
<p>Style Description</p>
<p>0 (default) The Data of the Stream is expected to be present for each Vert of the SubGeometry 1 The Encoder has ordered the VertBuffer by nonAnimated and animated, and only the data for the animated verts are stored. To make this work, the MeshBlock-Property “vertOffset” must be set (for each SubGeometry). This can only be used if “parsingStyleFrame” is false! 2 Only the data for the animated Verts is stored. To make this happen, a addional Stream has to be saved (add parsed as first stream) containing the original-list-Indicies of the animated verts.</p>
<p>The Encoder have to calculate the parsing-style to use, so we end up with the lowest file-size possible.</p>
<h2><a class="anchor" id="awd_pt2_14_5"></a>
AnimationSet (ID 113)</h2>
<p>An AnimationSet-Block is used to group multiple Animation-Blocks into one AnimationSet-Block. A AnimationSet-Blocks can be used for all types of Animation-Blocks, but one AnimationSet-Block cannot contain different types of Animations-Block. The AnimationSet-Block has no Animationset-type. Its Type is defined by the type of Animation-Blocks it contains. Atm the AnimationSet-Block can only be used for SkeletonAnimations and VertexAnimations.</p>
<table class="doxtable">
<tr>
<th>Offset </th><th>Size </th><th>Type </th><th>Description  </th></tr>
<tr>
<td>0 </td><td>Variable </td><td>VarString </td><td>Look-up name </td></tr>
<tr>
<td>Variable </td><td>2 </td><td>uint16 </td><td>Number of frames </td></tr>
<tr>
<td>Variable </td><td>Variable </td><td>NumAttrList </td><td>Animation properties (not used yet) </td></tr>
<tr>
<td>Variable </td><td>Variable </td><td>List of <a class="el" href="namespace_a_w_d_1_1_t_y_p_e_s.html#a67050e0d5b2ec92455d9df844eefa24b">AWD::TYPES::BADDR</a> </td><td>List of AnimationBlockIDs </td></tr>
<tr>
<td>Variable </td><td>Variable </td><td>UserAttrList </td><td>Animation user attributes </td></tr>
</table>
<p>Animation Properties</p>
<table class="doxtable">
<tr>
<th>ID </th><th>Name </th><th>Type </th><th>Default </th><th>Description  </th></tr>
<tr>
<td>1 </td><td>jointsPerVerticle </td><td>uint </td><td>4 </td><td>only used for SkeletonAnimationSet </td></tr>
</table>
<h2><a class="anchor" id="awd_pt2_14_6"></a>
Animator (ID 122)</h2>
<p>A Animator is the object that is used to bind a AnimationSet to a Mesh, and control its playback. Like the AnimationSet, this AnimatorBlock can be used for any time of Animation.</p>
<table class="doxtable">
<tr>
<th>Offset </th><th>Size </th><th>Type </th><th>Description  </th></tr>
<tr>
<td>0 </td><td>11 </td><td>BlockHeader </td><td><a class="el" href="awd_specs_2.html#awd_pt2_9_1">Block Header</a> </td></tr>
<tr>
<td>0 </td><td>Variable </td><td>VarString </td><td>Look-up name </td></tr>
<tr>
<td>Variable </td><td>Variable </td><td>TypedPropertiesList </td><td><a class="el" href="awd_specs_2.html#awd_pt2_animator_type">Animator-Type</a> and the type-specific properties </td></tr>
<tr>
<td>Variable </td><td>4 </td><td><a class="el" href="namespace_a_w_d_1_1_t_y_p_e_s.html#a0633e60becfa73b1f2e7681b000314c0">AWD::TYPES::UINT32</a> </td><td>AnimationSet ID </td></tr>
<tr>
<td>Variable </td><td>2 </td><td>uint16 </td><td>Number of TargetsIDs </td></tr>
<tr>
<td>Variable </td><td>4 * Number of TargetsIDs </td><td><a class="el" href="namespace_a_w_d_1_1_t_y_p_e_s.html#a0633e60becfa73b1f2e7681b000314c0">AWD::TYPES::UINT32</a> </td><td>Target ID </td></tr>
<tr>
<td>Variable </td><td>2 </td><td>uint16 </td><td>The Active State of the AnimationSet (index of current active anim-clip) </td></tr>
<tr>
<td>Variable </td><td>1 </td><td>bool </td><td>autoPlay (default=false) </td></tr>
<tr>
<td>Variable </td><td>Variable </td><td>NumAttrList </td><td>Animator properties </td></tr>
<tr>
<td>Variable </td><td>Variable </td><td>UserAttrList </td><td>Animator user attributes </td></tr>
</table>
<p>The type field defines the animator-type according to the following table:</p>
<h3><a class="anchor" id="awd_pt2_animator_type"></a>
Animator-Type</h3>
<table class="doxtable">
<tr>
<th>Type ID </th><th>Animator-Type  </th></tr>
<tr>
<td>1 </td><td>SkeletonAnimator </td></tr>
<tr>
<td>2 </td><td>VertexAnimator (no properties yet) </td></tr>
<tr>
<td>3 </td><td>UVAnimator (not used yet) </td></tr>
<tr>
<td>4 </td><td>ParticleAnimator (not used yet) </td></tr>
</table>
<p>SkeletonAnimator (type = 1)</p>
<table class="doxtable">
<tr>
<th>ID </th><th>Name </th><th>Type </th><th>Default  </th></tr>
<tr>
<td>1 </td><td>skeleton </td><td><a class="el" href="namespace_a_w_d_1_1_t_y_p_e_s.html#a67050e0d5b2ec92455d9df844eefa24b">AWD::TYPES::BADDR</a> </td><td>must be set </td></tr>
<tr>
<td>701 </td><td>use condensed indices </td><td>bool </td><td>false </td></tr>
</table>
<h2><a class="anchor" id="awd_pt2_14_6"></a>
Animator (ID 122)</h2>
<table class="doxtable">
<tr>
<th>Offset </th><th>Size </th><th>Type </th><th>Description  </th></tr>
<tr>
<td>0 </td><td>11 </td><td>BlockHeader </td><td><a class="el" href="awd_specs_2.html#awd_pt2_9_1">Block Header</a> </td></tr>
<tr>
<td>0 </td><td>Variable </td><td>VarString </td><td>Look-up name </td></tr>
<tr>
<td>Variable </td><td>2 </td><td>uint16 </td><td>Number of <a class="el" href="awd_specs_2.html#awd_pt2_uvanim_frame">UV Animation Frame</a> </td></tr>
<tr>
<td>Variable </td><td>Variable </td><td>NumAttrList </td><td>Animation properties </td></tr>
<tr>
<td>Variable </td><td>Variable </td><td>List of UVAnimFrame </td><td>List of <a class="el" href="awd_specs_2.html#awd_pt2_uvanim_frame">UV Animation Frame</a> </td></tr>
<tr>
<td>Variable </td><td>Variable </td><td>UserAttrList </td><td>Animation user attributes </td></tr>
</table>
<h3><a class="anchor" id="awd_pt2_uvanim_frame"></a>
UV Animation Frame</h3>
<table class="doxtable">
<tr>
<th>Offset </th><th>Size </th><th>Type </th><th>Description  </th></tr>
<tr>
<td>0 </td><td>24 </td><td>Matrix3x2 </td><td>Two-dimensional UV transformation. </td></tr>
<tr>
<td>24 </td><td>1 </td><td>uint16 </td><td>Duration in milliseconds </td></tr>
</table>
<h2><a class="anchor" id="awd_pt2_14_7"></a>
TimeLine</h2>
<p>No already existing Block to compare to. A Timeline is what a MovieClip is called in FlashUI. It consists of a number of frames. Each Frame containsa number of frame-commands. The frame-commands are used to put display-objects into the scenegraph. A timeline can be added to another timeline, using these commands.</p>
<table class="doxtable">
<tr>
<th>Offset </th><th>Size </th><th>Type </th><th>Description  </th></tr>
<tr>
<td>0 </td><td>11 </td><td>BlockHeader </td><td><a class="el" href="awd_specs_2.html#awd_pt2_9_1">Block Header</a> </td></tr>
<tr>
<td>11 </td><td>variable </td><td>VarString </td><td>Name </td></tr>
<tr>
<td>variable </td><td>1 </td><td>bool </td><td>IsScene (isRoot) </td></tr>
<tr>
<td>variable </td><td>1 </td><td>uint8 </td><td>SceneID (if we have multiple scenes) </td></tr>
<tr>
<td>variable </td><td>1 </td><td>uint16 </td><td>Number of Frames </td></tr>
<tr>
<td>variable </td><td>variable </td><td>List of AWDTimeLineFrame </td><td>All the TimeLine Frames </td></tr>
<tr>
<td>variable </td><td>variable </td><td>NumAttrList </td><td>Timeline-properties </td></tr>
<tr>
<td>variable </td><td>variable </td><td>UserAttrList </td><td>User Attributes </td></tr>
</table>
<h3><a class="anchor" id="awd_pt2_14_7_1"></a>
AWDTimeLineFrame</h3>
<p>Each Frame has a duration, so on import we can count the durations up to total duration.</p>
<table class="doxtable">
<tr>
<th>Offset </th><th>Size </th><th>Type </th><th>Description  </th></tr>
<tr>
<td>0 </td><td>4 </td><td>Float32 </td><td>Frame Duration </td></tr>
<tr>
<td>0 </td><td>2 </td><td>uint16 </td><td>number of Frame-labels - the next 2 properties are parsed for each frame-label </td></tr>
<tr>
<td>variable </td><td>2 </td><td>uint8 </td><td>Frame Identifier-type (type of frame label) </td></tr>
<tr>
<td>variable </td><td>variable </td><td>VarString </td><td>Frame Identifier (Frame label </td></tr>
<tr>
<td>variable </td><td>1 </td><td>uint16 </td><td>Number of AWDFrameCommand </td></tr>
<tr>
<td>variable </td><td>variable </td><td>List of Frame-Command-Blocks </td><td>Frame Command-blocks </td></tr>
<tr>
<td>variable </td><td>4 </td><td>uint32 </td><td>Length of code-string </td></tr>
<tr>
<td>variable </td><td>Length of code-string</td><td>String </td><td>The frame-script (js-code) </td></tr>
<tr>
<td>variable </td><td>variable </td><td>UserAttrList </td><td>User Attributes </td></tr>
</table>
<h2><a class="anchor" id="awd_pt2_14_8"></a>
AWDFrameCommand</h2>
<p>Adobes Frame-Generator provides us with FrameCommands for all the different properties that we might want to update on a object.<br />
This means, that we might have multiple Commands for the same object and the same frame.<br />
For <a class="el" href="namespace_a_w_d.html" title="The namespace used for the complete libawd. ">AWD</a> we will merge the commands, so we only will ever have 1 command per frame and object.<br />
The types of AWD-frameCommands are:</p>
<table class="doxtable">
<tr>
<th>ID </th><th>FrameCommand-Name  </th></tr>
<tr>
<td>0 </td><td>Update Object </td></tr>
<tr>
<td>1 </td><td>Remove Object </td></tr>
<tr>
<td>2 </td><td>Update Sound </td></tr>
</table>
<h3><a class="anchor" id="awd_pt2_14_8_1"></a>
Remove Object Command</h3>
<table class="doxtable">
<tr>
<th>Offset </th><th>Size </th><th>Type </th><th>Description </th><th>Default  </th></tr>
<tr>
<td>1 </td><td>4 </td><td>uint32 </td><td>The ObjectID of the object to remove </td><td>0 (ERROR) </td></tr>
</table>
<h3><a class="anchor" id="awd_pt2_add_sound_command"></a>
Add Sound Command</h3>
<p>The Add Sound Command is s asepperate Command, because the properties for a this command are very different than the properties for the commands that affect other type of objects.</p>
<table class="doxtable">
<tr>
<th>Offset </th><th>Size </th><th>Type </th><th>Description </th><th>Default  </th></tr>
<tr>
<td>1 </td><td>4 </td><td>uint32 </td><td>The ObjectID that should be applied to the Sound </td><td>0 (ERROR) </td></tr>
<tr>
<td>1 </td><td>4 </td><td>uint32 </td><td>The Ressource (<a class="el" href="namespace_a_w_d.html" title="The namespace used for the complete libawd. ">AWD</a>) ID of the Sound to add </td><td>0 (ERROR) </td></tr>
</table>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000004">Todo:</a></b></dt><dd>Sound-properties like Loop, should be added here</dd></dl>
<h3><a class="anchor" id="awd_pt2_14_8_3"></a>
Update Object Command</h3>
<p>The UpdateObject command includes all the other commands that adobe outputs. <br />
We first read a list of bool, to decide what properties of the objects should be updated. <br />
The first of the bool decides whether we are updating an existing item, or if we want to add a new item to the timelines-display list. <br />
 </p><table class="doxtable">
<tr>
<th>Offset </th><th>Size </th><th>Type </th><th>Description  </th></tr>
<tr>
<td>0 </td><td>9 </td><td>Update Object Command Header </td><td>defines what is expected as body </td></tr>
<tr>
<td>9 </td><td>variable </td><td>Update Object Command Body </td><td>the variable body of the Command </td></tr>
</table>
<h3><a class="anchor" id="awd_pt2_14_8_34"></a>
Update Object Command -  header</h3>
<table class="doxtable">
<tr>
<th>Offset </th><th>Size </th><th>Type </th><th>Name </th><th>Description  </th></tr>
<tr>
<td>0 </td><td>1 </td><td>boolean </td><td>addOrUpdate </td><td>new = 0 / update = 1 </td></tr>
<tr>
<td>1 </td><td>1 </td><td>boolean </td><td>updateDisplayMatrix </td><td>no-displaymatrix = 0 / displaymatrix = 1 </td></tr>
<tr>
<td>2 </td><td>1 </td><td>boolean </td><td>updateColorMatrix </td><td>no-colormatrix = 0 / colormatrix = 1 </td></tr>
<tr>
<td>3 </td><td>1 </td><td>boolean </td><td>changeDepth </td><td>no-depth-change = 0 / depth-change = 1 </td></tr>
<tr>
<td>4 </td><td>1 </td><td>boolean </td><td>changeFilter </td><td>no-filter-change = 0 / filter-change = 1 </td></tr>
<tr>
<td>5 </td><td>1 </td><td>boolean </td><td>changeVisibility </td><td>no-visible-change = 0 / visibility-change = 1 </td></tr>
<tr>
<td>6 </td><td>1 </td><td>boolean </td><td>changeBlendMode </td><td>no-blendmode = 0 / blendmode = 1 </td></tr>
<tr>
<td>7 </td><td>1 </td><td>boolean </td><td>updateMaskDepth </td><td>no-maskDepth= 0 / maskDepth= 1 </td></tr>
</table>
<h3><a class="anchor" id="awd_pt2_14_8_35"></a>
Update Object Command -  Body</h3>
<table class="doxtable">
<tr>
<th>Offset </th><th>Size </th><th>Type </th><th>Description </th><th>Parse if  </th></tr>
<tr>
<td>0 </td><td>4 </td><td>uint32 </td><td>Object ID - This is not depentant on any boolean (objectID must always be included). It is either the ID that is assigned to the new object, or the ID of the already existing object, that should be updated</td><td>always </td></tr>
<tr>
<td>4 </td><td>4 </td><td>Blockaddr </td><td>The AWD-ID of the object to add or update. </td><td>addOrUpdate=false </td></tr>
<tr>
<td>variable </td><td>24 </td><td>6 x float32 </td><td>DisplayMatrix2x3 </td><td>updateDisplayMatrix </td></tr>
<tr>
<td>variable </td><td>24 </td><td>20 x float32 </td><td>ColorMatrix4x5 </td><td>updateColorMatrix </td></tr>
<tr>
<td>variable </td><td>4 </td><td>uint32 </td><td>Depth of the Clip </td><td>changeDepth </td></tr>
<tr>
<td>variable </td><td>TODO </td><td>TODO </td><td>TODO:specs for filter </td><td>changeFilter </td></tr>
<tr>
<td>variable </td><td>1 </td><td>boolean </td><td>Visible state of object </td><td>changeVisibility </td></tr>
<tr>
<td>variable </td><td>variable </td><td>varString </td><td>The instance-name of the new object. </td><td>setInstanceName </td></tr>
<tr>
<td>variable </td><td>1 </td><td>uint8 </td><td>BlendMode </td><td>changeBlendMode </td></tr>
<tr>
<td>variable </td><td>1 </td><td>uint32 </td><td>The depth of clip-mask. 0=not used as mask </td><td>updateMaskDepth </td></tr>
<tr>
<td>variable </td><td>2 </td><td>uint16 </td><td>Number of subshapes </td><td>This should always be parsed, but should be 0 if the object found at objectID / ressourceID is not a shape </td></tr>
<tr>
<td>variable </td><td>variable </td><td>list of BlockAddr </td><td>The awd-ID to the fill-object for each subMesh </td><td>If number of subshapes is &gt; 0 </td></tr>
</table>
<blockquote class="doxtable">
<p>Claus suggested to get rid of the object-id, because we could use the objects-depth instead. I think in <a class="el" href="namespace_a_w_d.html" title="The namespace used for the complete libawd. ">AWD</a> this is not possible, because we rely heavily on that the objectID is correct for a object for all FrameCommands for this timeline, <br />
 even if changing the object depth. </p>
</blockquote>
<h1><a class="anchor" id="awd_pt2_15"></a>
Sound Blocks</h1>
<h2><a class="anchor" id="awd_pt2_15_1"></a>
Sound</h2>
<p>The structure of the Sound-Block is the same as the structure of the texture-Block.<br />
They only differ in their Block-Type, and in the type of properties they can have in their properties-list.<br />
 As with textures, the sound can be present in the file as embed data, or as URL.<br />
In either way, the parser will stop parsing the current <a class="el" href="namespace_a_w_d.html" title="The namespace used for the complete libawd. ">AWD</a>, hand the sound-data over to the Parsing-system, and wait until processing has finished.<br />
</p>
<h5>Sound-properties</h5>
<table class="doxtable">
<tr>
<th>ID </th><th>Size </th><th>Type </th><th>Name </th><th>Description  </th></tr>
<tr>
<td>TODO </td><td>TODO </td><td>TODO </td><td>TODO </td><td>TODO </td></tr>
</table>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000005">Todo:</a></b></dt><dd>The sound-properties are defined in the <a class="el" href="awd_specs_2.html#awd_pt2_add_sound_command">Add Sound Command</a>, so we should not need to store any properties on the sound-block.</dd></dl>
<h1><a class="anchor" id="awd_pt2_16"></a>
Text BLocks</h1>
<h2><a class="anchor" id="awd_pt2_16_1"></a>
Font</h2>
<p>Because a font can have different styles, a font-block contains a list of font-styles.<br />
Each font-style provides a 2d-subgeometry for each included character of this font-style.<br />
Each fontstyle has a name.<br />
 Standart FontStyle names:</p>
<ul>
<li>Regular</li>
<li>Bold</li>
<li>Italc</li>
<li>Bold-Italic</li>
</ul>
<p>This is not a fixed list, other FontStyle-names can be used.<br />
 After parsing, we should be able to get a character of a font (2D-subgeometry) for a specific fontstyle, from the font.<br />
 For localization, the Font-blocks should be saved in sepperate AWD-files.<br />
</p>
<table class="doxtable">
<tr>
<th>Offset </th><th>Size </th><th>Type </th><th>Description  </th></tr>
<tr>
<td>0 </td><td>11 </td><td>Blockheader </td><td>block_header </td></tr>
<tr>
<td>11 </td><td>variable </td><td>varString </td><td>The FontName </td></tr>
<tr>
<td>variable </td><td>1 </td><td>uint8 </td><td>Number of <a class="el" href="awd_specs_2.html#awd_pt2_font_style">FontStyle</a> </td></tr>
<tr>
<td>variable </td><td>variable </td><td>List of FontStyle </td><td>List of <a class="el" href="awd_specs_2.html#awd_pt2_font_style">FontStyle</a> </td></tr>
<tr>
<td>variable </td><td>variable </td><td>NumAttrList </td><td>Font-properties </td></tr>
<tr>
<td>variable </td><td>variable </td><td>UserAttrList </td><td>User Attributes </td></tr>
</table>
<h3><a class="anchor" id="awd_pt2_font_style"></a>
FontStyle</h3>
<table class="doxtable">
<tr>
<th>Offset </th><th>Size </th><th>Type </th><th>Description  </th></tr>
<tr>
<td>0 </td><td>variable </td><td>varString </td><td>Font-style as string (e.g. "regular"/ "bold" / etc...) </td></tr>
<tr>
<td>variable </td><td>1 </td><td>uint32 </td><td>Number of <a class="el" href="awd_specs_2.html#awd_pt2_font_shape">FontShape</a> for this FontStyle (is uint32 enough???) </td></tr>
<tr>
<td>variable </td><td>variable </td><td>List of FontShapes </td><td>List of <a class="el" href="awd_specs_2.html#awd_pt2_font_shape">FontShape</a> for this FontStyle </td></tr>
</table>
<h3><a class="anchor" id="awd_pt2_font_shape"></a>
FontShape</h3>
<table class="doxtable">
<tr>
<th>Offset </th><th>Size </th><th>Type </th><th>Description  </th></tr>
<tr>
<td>0 </td><td>4 </td><td>uint32 </td><td>char that this SubGeometry should display </td></tr>
<tr>
<td>4 </td><td>variable </td><td>SubGeometry</td><td>The SubGeometry for this FontShape </td></tr>
</table>
<h2><a class="anchor" id="awd_pt2_16_2"></a>
Text-Format Block</h2>
<p>A TextFormat contains one ore more Text-format elements that can be used to style a Text.<br />
 </p><table class="doxtable">
<tr>
<th>Offset </th><th>Size </th><th>Type </th><th>Description  </th></tr>
<tr>
<td>0 </td><td>11 </td><td>Blockheader </td><td>block_header </td></tr>
<tr>
<td>variable </td><td>1 </td><td>uint8 </td><td>Number of <a class="el" href="awd_specs_2.html#awd_pt2_test_format">Text-format Element</a> </td></tr>
<tr>
<td>variable </td><td>variable </td><td>List of FontStyle </td><td>List of <a class="el" href="awd_specs_2.html#awd_pt2_test_format">Text-format Element</a> </td></tr>
<tr>
<td>variable </td><td>variable </td><td>NumAttrList </td><td>Text-format-properties </td></tr>
<tr>
<td>variable </td><td>variable </td><td>UserAttrList </td><td>User Attributes </td></tr>
</table>
<h3><a class="anchor" id="awd_pt2_test_format"></a>
Text-format Element</h3>
<p>A Text-Format Element can be stored inside a Text-Format block or a Text-Element block.<br />
 </p><table class="doxtable">
<tr>
<th>Offset </th><th>Size </th><th>Type </th><th>Description  </th></tr>
<tr>
<td>0 </td><td>2 </td><td>unti16 </td><td>The id of this Text-format </td></tr>
<tr>
<td>2 </td><td>Variable </td><td>var_string </td><td>The name of this Text-format </td></tr>
<tr>
<td>Variable </td><td>Variable </td><td>NummAttrList </td><td>The properties of this Text-format. </td></tr>
</table>
<p>Text-Format Properties:</p>
<table class="doxtable">
<tr>
<th>ID </th><th>Size </th><th>Type </th><th>Name </th><th>Description  </th></tr>
<tr>
<td>TODO </td><td>TODO </td><td>TODO </td><td>TODO </td><td>TODO </td></tr>
</table>
<h2><a class="anchor" id="awd_pt2_16_3"></a>
TextElement</h2>
<p>Textelement is the element that is used to define a Text for display on the screen.<br />
 One Text-element might contain mutliple Text-Paragraphs.<br />
 A text-paragraph defines the behavior of (multi-line) texts, and can contain a number of TextRuns.<br />
 A Text-Element with only a single line, contains only one Text-Paragraph.<br />
 A TextRun is a series of text-letters that share the same Text-Format (Font, FontStyle, FontSize, etc.).<br />
 There is a big difference if a Text-element should be using language-localization or not.<br />
 Like for all other display-objects, things like DisplayMatrix and Instancename of TextElements are set by the FrameCommand, that adds them into a timeline.<br />
 If no localization is used, of course we need to include all the Paragraphs and TextRuns-information into this TextElement directly, so we can collect and arrange the shapes we need to display the text.<br />
 If localization is used, we have two Options:<br />
</p><ul>
<li>Fully Localization:<ul>
<li>We can redirect/map/translate this Text-element to another localized Text-element (probably loaded from another AWD-file),<br />
 so that each localization can have its unique Text-formatting. <br />
 In this case, the only property that needs to be provided by the TextField-Block must be a localizationID, <br />
 all other TextureFormatting and Content will be provided by the localized TextField we redirect to.<br />
</li>
</ul>
</li>
<li>Content Localization:<ul>
<li>Only the Content of this TextField is redirected/mapped/translated by localized content, <br />
 that can be found at localizationID. The Text-Properties are still used from the TextField, and global for all languages. <br />
 This comes with the restriction, that for "Content localization", a TextField should have only one TextRun.<br />
 The first option could be nice for workflow, where a artists doing localization inside the flash-project, and adjust the text-formatting as needed. <br />
We could provide a special exporter option like "Create language awd", that would enable to export only all the text-fields in the document (that are now localized) while taking care that they are still saved with same localizationID as the original Textfields.<br />
 At first glance, the first option (Fully Localization) seams like the way to go.<br />
 But what is with supporting basic html parsing into the function that collects and arranges the text-shapes for display.<br />
 If we would include this feature, the second option "Content Localization" can now also have localized text-formatting (via html).<br />
 So i am not sure what is the best way to do it.<br />
</li>
</ul>
</li>
</ul>
<table class="doxtable">
<tr>
<th>Offset </th><th>Size </th><th>Type </th><th>Description  </th></tr>
<tr>
<td>0 </td><td>11 </td><td>Blockheader </td><td>block_header </td></tr>
<tr>
<td>11 </td><td>1 </td><td>uint8 </td><td>Type of textfield (static/dynamic/input) </td></tr>
<tr>
<td>12 </td><td>1 </td><td>uint8 </td><td>Type of textfield-renderer to use (For now only GPU-Shape-render, but might be useful to have the option to switch renderer of text per textField...- even for localized textfields) </td></tr>
<tr>
<td>13 </td><td>1 </td><td>uint8 </td><td>localization type (0: none, 1:Full, 2:Content) </td></tr>
<tr>
<td>14 </td><td>4 </td><td>uint32 </td><td>The ID for localization lookup - only parsed if localization-type&gt;0 </td></tr>
<tr>
<td>variable</td><td>1 </td><td>uint8 </td><td>number of text-format stored with this text-element (might be 0, when text-formats are stored in blocks) </td></tr>
<tr>
<td>variable</td><td>variable </td><td><a class="el" href="awd_specs_2.html#awd_pt2_test_format">Text-format Element</a> </td><td>number of text-format stored with this text-element (might be 0, when text-formats are stored in blocks) </td></tr>
<tr>
<td>variable</td><td>2 </td><td>uint8 </td><td>number of <a class="el" href="awd_specs_2.html#awd_pt2_paragraph">Text-Paragraph</a> must be 0 if localization-type==1 </td></tr>
<tr>
<td>variable</td><td>variable </td><td>list of Paragraph </td><td>The list of <a class="el" href="awd_specs_2.html#awd_pt2_paragraph">Text-Paragraph</a>, that are containing TextRun - if localization-type==2 only the first TextRun will be used (replacing all TextRuns in all paragraphs) </td></tr>
<tr>
<td>variable</td><td>variable </td><td>NumAttrList </td><td>TextField-properties </td></tr>
<tr>
<td>variable</td><td>variable </td><td>UserAttrList </td><td>User Attributes </td></tr>
</table>
<h3><a class="anchor" id="awd_pt2_paragraph"></a>
Text-Paragraph</h3>
<table class="doxtable">
<tr>
<th>Offset </th><th>Size </th><th>Type </th><th>Description  </th></tr>
<tr>
<td>0 </td><td>variable </td><td>NumAttrList </td><td>Paragraph-properties (better not use NumAttrList, but just store some properties directly ?) </td></tr>
<tr>
<td>variable </td><td>2 </td><td>uint16 </td><td>The Number of <a class="el" href="awd_specs_2.html#awd_pt2_textrun">TextRun</a> </td></tr>
<tr>
<td>variable </td><td>variable </td><td>list of TextRun </td><td>The list of <a class="el" href="awd_specs_2.html#awd_pt2_textrun">TextRun</a>,that are defining Text-formatting for a series of letter </td></tr>
</table>
<h5>ParagraphProperties</h5>
<p>TODO: add specs for Paragraph-properties</p>
<table class="doxtable">
<tr>
<th>ID </th><th>Size </th><th>Type </th><th>Name </th><th>Description  </th></tr>
<tr>
<td>TODO</td><td>TODO</td><td>TODO</td><td>TODO</td><td>TODO </td></tr>
</table>
<h3><a class="anchor" id="awd_pt2_textrun"></a>
TextRun</h3>
<table class="doxtable">
<tr>
<th>Offset </th><th>Size </th><th>Type </th><th>Description  </th></tr>
<tr>
<td>0 </td><td>variable </td><td>varstring </td><td>The text of this TextRun </td></tr>
<tr>
<td>variable </td><td>2 </td><td>uint16 </td><td>The id of the text-format to use </td></tr>
</table>
<h3><a class="anchor" id="awd_pt2_textfiel_propsh"></a>
TextField-Properties</h3>
<p>TODO: add specs for textfield-properties (renderAsHtml / etc)</p>
<table class="doxtable">
<tr>
<th>ID </th><th>Size </th><th>Type </th><th>Name </th><th>Description  </th></tr>
<tr>
<td>TODO</td><td>TODO</td><td>TODO</td><td>TODO</td><td>TODO </td></tr>
</table>
<h1><a class="anchor" id="awd_pt2_15"></a>
Sound Blocks</h1>
<h2><a class="anchor" id="awd_pt2_15_1"></a>
Sound</h2>
<p>A Command Block is used to execute a action defined by the CommandID. In AWD2.1 the only available action is: “PutObjectIntoSceneGraph”.</p>
<table class="doxtable">
<tr>
<th>Offset </th><th>Size </th><th>Type </th><th>Description  </th></tr>
<tr>
<td>0 </td><td>11 </td><td>BlockHeader </td><td><a class="el" href="awd_specs_2.html#awd_pt2_9_1">Block Header</a> </td></tr>
<tr>
<td>11 </td><td>1 </td><td>bool </td><td>has SceneHeader </td></tr>
<tr>
<td>12 </td><td>Variable </td><td>SceneHeader </td><td>awd_pt2_12_1(optional) </td></tr>
<tr>
<td>11 </td><td>2 </td><td>uint </td><td>Number of Commands </td></tr>
<tr>
<td>0 </td><td>Variable </td><td>TypedpropertiesList * </td><td>List of Command-properties </td></tr>
<tr>
<td>Variable </td><td>Variable </td><td>NumAttrList </td><td>Commandattributes. </td></tr>
<tr>
<td>Variable </td><td>Variable </td><td>UserAttrList </td><td>User attributes. </td></tr>
</table>
<p>Table 18: Container block fields (in addition to common scene object fields).</p>
<p>Type-ID | name | Description ----&mdash; |---------------&mdash; |----------&mdash; 1 |Put Object into SceneGraph | 2 |Copy SceneGraph-Object |</p>
<p>Table 14: Command-Types</p>
<p>Command “Put-Object-into-SceneGraph” - Properties</p>
<table class="doxtable">
<tr>
<th>ID </th><th>Name </th><th>Type  </th></tr>
<tr>
<td>1 </td><td>targetObject </td><td>BADDR </td></tr>
<tr>
<td>2 </td><td>Parent-Object </td><td>BADDR </td></tr>
</table>
<h2><a class="anchor" id="awd_pt2_15_2"></a>
Namespace blocks (ID 254)</h2>
<p>The namespace block is a block that must exist in any <a class="el" href="namespace_a_w_d.html" title="The namespace used for the complete libawd. ">AWD</a> file with user extensions. A namespace block couples a short numeric "namespace handle" which is unique within the file, with a namespace string identifier which should be globally unique. To make sure that namespace string identifiers are unique, good practice is using a URI with a domain that is controlled by the defining party, e.g. <a href="http://www.away3d.com/prefab/awpns">http://www.away3d.com/prefab/awpns</a> for the Prefab3D AWP project format. The block body itself consists of an 8-bit integer for the numeric ID, and a variable string for the URI/string identifier, as defined by the below table.</p>
<table class="doxtable">
<tr>
<th>Offset </th><th>Size </th><th>Type </th><th>Description  </th></tr>
<tr>
<td>0 </td><td>1 </td><td>uint8 </td><td>Namespace handle (Zero is reserved for null namespaces.) </td></tr>
<tr>
<td>1 </td><td>Variable </td><td>VarString </td><td>Namespace URI/string identifier. </td></tr>
</table>
<p>Table 36: Structure of a single namespace definition, multiple of which can occur in a namespace list block.</p>
<p>NOTE: Zero must not be used as a numeric namespace ID. It is reserved for use as a null reference when a block or user attribute does not have a namespace. See the section on "Extending AWD" for more information about how to use namespaces.</p>
<h2><a class="anchor" id="awd_pt2_15_3"></a>
Meta-data blocks (ID 255)</h2>
<p>The meta-data block is something that encoders must include in an <a class="el" href="namespace_a_w_d.html" title="The namespace used for the complete libawd. ">AWD</a> document to define metadata such as creation date, name and version of encoder etc. Only one meta-data block should exist in an <a class="el" href="namespace_a_w_d.html" title="The namespace used for the complete libawd. ">AWD</a> document, and it should occur at the very start of the block list. The structure is very simple, comprising only a numeric property list.</p>
<table class="doxtable">
<tr>
<th>Offset </th><th>Size </th><th>Type </th><th>Description  </th></tr>
<tr>
<td>0 </td><td>Variable </td><td>NumAttrList </td><td>Meta-data properties. </td></tr>
</table>
<p>The properties of a meta-data blocks are defined by the following table.</p>
<table class="doxtable">
<tr>
<th>ID </th><th>Name </th><th>Type </th><th>Description  </th></tr>
<tr>
<td>1 </td><td>Timestamp </td><td><a class="el" href="namespace_a_w_d_1_1_t_y_p_e_s.html#a0633e60becfa73b1f2e7681b000314c0">AWD::TYPES::UINT32</a> </td><td>Generation date and time defined as seconds since the Epoch (00:00, 1/1 1970.) </td></tr>
<tr>
<td>2 </td><td>Encoder name </td><td>ConstString </td><td>Name of encoder (i.e. the library or tool used to encode the <a class="el" href="namespace_a_w_d.html" title="The namespace used for the complete libawd. ">AWD</a> file, e.g. libawd.) </td></tr>
<tr>
<td>3 </td><td>Encoder version </td><td>ConstString </td><td>Encoder version. </td></tr>
<tr>
<td>4 </td><td>Generator name </td><td>ConstString </td><td>Name of generator (i.e. the tool used to create the content, e.g. Maya.) </td></tr>
<tr>
<td>5 </td><td>Generator version </td><td>ConstString </td><td>Generator version. </td></tr>
</table>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="index.html">Documentation</a></li><li class="navelem"><a class="el" href="awd_specs.html">AWD 3.0 Specifications</a></li>
    <li class="footer">Generated on Mon Feb 2 2015 18:04:26 for cpp-libawd by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.8 </li>
  </ul>
</div>
</body>
</html>
