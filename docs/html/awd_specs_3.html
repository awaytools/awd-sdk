<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.8"/>
<title>cpp-libawd: Part III: Using AWD</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="Logo_AwayTools_300x300.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">cpp-libawd
   </div>
   <div id="projectbrief">cpp-library to convert and prepare AWD-data</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.8 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('awd_specs_3.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Part III: Using <a class="el" href="namespace_a_w_d.html" title="The namespace used for the complete libawd. ">AWD</a> </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>AWD 3.0 Specification in markdown format.</p>
<h1><a class="anchor" id="awd_pt3_1"></a>
Official AWD tools</h1>
<p>The official AWD tool-chain is a constantly growing set of tools, importers/exporters and programming language libraries and extensions. This section details the tools available at the time of writing. Visit the AWD project page on GitHub (<a href="https://github.com/awayTools">https://github.com/awayTools</a>) for the latest information about available AWD tooling.</p>
<h2><a class="anchor" id="awd_pt3_1_1"></a>
AWD SDK</h2>
<p>The AWD SDK has been created to aid and greatly simplify the creation of AWD importers and exporters. Furthermore, it exists to help prevent discrepancies between encoders and decoders. An AWD file that was encoded using the AWD SDK should be expected to structurally conform to the AWD specification, and the AWD SDK can be used to reliably decode a conforming AWD file. Whether the content is logically conforming (e.g. whether the contents of a data stream has been sequentially ordered in accordance with what the specification dictates) is still up to the encoder programmer. Below are the modules of the AWD SDK. For more information on the AWD SDK, how to build it and use it, see the AWD GitHub Project page. Below is a list of the programming languages supported in the AWD SDK. The libawd library for C++ The main reference implementation of AWD is the libawd C++ library.</p>
<h2><a class="anchor" id="awd_pt3_2"></a>
PyAWD - AWD for Python</h2>
<p>PyAWD is a Python module for working with AWD files. It's available as a Python binding and object-oriented wrapper for the C libawd library, or as a standalone python library that does not require libawd to run (but does not perform as well as the libawd wrapper.)</p>
<h2><a class="anchor" id="awd_pt3_1_3"></a>
Official importer/exporter implementations</h2>
<p>These are importers and exporters that are being officially developed and maintained as a part of the AWD project, and that are either in a usable state or planned at the time of releasing this document. Please visit the AWD project page on Google Code for the latest set of importers/exporters, and for links to any known community implementations. Vendor/Application Export Import Real-time Prefab3D Yes Yes No Blender Yes No No Autodesk Maya Yes No No Autodesk 3dsMax Yes No No AwayBuilder Yes Yes Yes Maxon Cinema4D Yes Yes No</p>
<h1><a class="anchor" id="awd_pt3_2"></a>
PyAWD - AWD for Python</h1>
<p>AWD is user-extendable by the means of user attributes and user blocks. Attributes are a versatile way to augment an already existing block type, such as a mesh instance or a material, with custom properties. User blocks on the other hand can be used to add top-level data types to the format, like player spawn points in a game, force fields in a physics simulator, or a list of configuration settings in an editor. User attributes User attributes are key/value pairs with plaintext keys that can be appended to most AWD block types. These can be utilized by user applications to augment AWD blocks with application-specific properties, such as physics properties or game settings. See the Part II section called "Attributes" for more information on how to add user attributes to a block. User blocks The term "user block" refers to a block type that is not defined by the AWD file format specification, but rather by an extending entity (i.e. a file format user.) User blocks share the same block header as any other block, but must be defined in a non-null namespace to distinguish them from AWD blocks. Namespaces in AWD When extending AWD, there is a need to mark those blocks that do not belong to standard AWD as belonging to some other context, a "namespace". That way the same numeric block type identifier can be used for both a standard AWD block and a block defined by the user application. There is also the rare case where a single AWD file has been influenced by several separate encoders in which two different user attributes have the same key/name. To prevent files like these from being incorrectly parsed by user-extended parsers, any encoder that extends AWD must use namespaces with user attributes. Namespaces serve the purpose of coupling a user attribute or user block with an identifier that is guaranteed to be unique, such as a URI. The AWD namespaces are inspired by those in XML, where a namespace URI is defined once in a document and any element belonging to that namespace subsequently identifies the namespace using a shortened ID. In AWD, the shortened ID is an 8-bit unsigned integer that is defined in a namespace block, and then referenced in every user attribute and user block. Using the namespace block An encoder that extends AWD must insert a namespace block before any user block or block with user attributes appears in the document. It's good practice to put the namespace block first in the file. See the section "Namespace block" for the exact structure of this block. Picking a namespace identifier A namespace identifier can be any string that fits in a VarString. The main requirement is that it is unique within the file where it's used, but it lies in the interest of the user application that it is also consistent and globally unique, so that a user parser can identify blocks belonging to it's namespace. A user application hosted at example.com could use "http://example.com/awdns" as it's AWD namespace identifier, which can be assumed to be unique not only in a particular file, but also consistent and universal so that it can be hardcoded into the custom parser. If an encoder intends to create a namespace in a file, any existing namespace definitions must be inspected by the encoder so that an ambiguous identifier is not added (e.g. if the original file was encoded by the same encoder and already contains user blocks or attributes in the relevant namespace.) Two namespaces within a document must not have the same numeric handle or string identifier. Parsing an AWD document AWD is designed for linear parsing, or even streaming and “block-wise” parsing of such a stream. It should never be necessary to seek backwards in a file, and unless a particular type of content has not been implemented in the parser and thus is skipped, even forward seeking is rare. Handling block references Because internal block references are always made backwards, node B can only refer to node A if B occurs after A in the document. As a block is read, the parser must determine whether to store a reference to it's internal representation of that block depending on it's ID. If the block ID is zero, this is a promise from the encoder that there will be no references to this block in the document, so it is not necessary for the parser to hold on to it. However, if the block ID is greater than zero, the parser should store a reference to it's internal representation of that block in a lookup table by ID. When any reference is encountered, this lookup table can be used for random access to the correct block representation by ID. Using Away3D as an example, when the parser encounters a TriangleGeometry block, it will create a Geometry instance and store it in a vector with numeric indices. When a MeshInstance occurs with a reference to this geometry block, an instance of the Away3D Mesh class will be created and it's geometry property assigned to the previously created Geometry instance. The latter can easily be retrieved from the lookup vector using the reference ID in the MeshInstance block. Handling unrecognized elements Because AWD can be extended both by users and future versions of the format, a conforming parser needs to be able to deal with blocks that it does not recognize. 55 If a block is encountered that uses an unknown block ID or namespace, the entire block should be skipped using the size field that is always defined in the common block header. Blocks in unknown namespaces can always be skipped unless a parser is expecting some kind of user-defined block. A parser library should delegate user blocks (blocks in unknown namespaces) to the application code so that it's up to the application logic to decide whether they need to be parsed. Parsing extended AWD documents User-defined blocks will always contain a reference to a namespace other than the default Null namespace (see section on User-defined blocks and Extending AWD). That way a particular user block can be analyzed and a decision can be made whether it's in a namespace that the parser is expecting, or whether it should be skipped. Namespaces must be defined early (usually first) in the file through the use of namespace blocks. From the content of such blocks, a parser can create a look-up table for namespace identifier strings, and when a namespace reference occurs determine from the look-up table whether the user block or attribute is in a namespace which it expects and understands. Another common way for extension are the user attributes that can be attached to almost any block. As with user blocks, attributes have a length field, allowing them to be skipped if the attribute key, value type, or the namespace in which the attribute is defined, is unrecognized. Optionally, if user attributes are concluded to never be relevant, a parser can skip all attributes belonging to a block using the length field of the attribute list. See the section Attributes fore more information about attributes.</p>
<h1><a class="anchor" id="awd_pt3_3"></a>
AWD Limitations</h1>
<p>There are some limitations inherent with the way AWD is designed. The following is a list of such limitations (per file unless otherwise stated.) General limitations Feature Limit Reason AWD file size (min) 11 bytes Size of header. AWD file size (max) 4 GB Limited to max value of the body length header field (32 bit unsigned integer.) Not applicable to streams. Number of blocks &gt;4 billion 32-bit block address. Number of namespaces 256 (incl. Null) 8-bit namespace handles. Block types (per namespace) 256 8-bit block type fields. Block types (total) 65535 16 bits total for namespace and block types. Block data length 4GB 32-bit block length field. 56 AWD data type limitations Feature Limit Reason Length of VarStrings 65535 single-byte characters, less multi-byte characters. 16-bit length field. Number of numeric attributes (per list) 65535 16-bit ID field Number of text attributes (per list) &gt;400 million Assuming attribute names with three bytes/characters and a single-byte value (e.g. Boolean). Limited by attribute element length and 32-bit list length identifier. Geometry limitations Feature Limit Reason Materials/sub-meshes per mesh or sub-paths per path. 65535 16 bit length field Mesh vertices &gt;350 million 32 bit stream length field, 12 bytes per vertex (optimized for size.) Mesh triangles &gt;350 million 32 bit stream length field, 12 bytes per triangle (optimized for size.) Path quadratic segments &gt;119 million 32 bit stream length field, 12 bytes per point (optimized for size), 3 points per segment. Path cubic segments &gt;89 million 32 bit stream length field, 12 bytes per point (optimized for size), 4 points per segment.</p>
<h1><a class="anchor" id="awd_pt3_4"></a>
AWD Structure examples</h1>
<p>Below are some examples of simple AWD files to illustrate the structure of an uncompressed file. The [N] symbol illustrates a link (numeric reference) to another block with the ID N. Even though the indentation of the lists in these examples might imply a tree structure, such structure only exists logically, whereas the actual “physical” representation of data in the file is linear, as is the parsing. Removed temporarily while the format is still in motion. 57 </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="index.html">Documentation</a></li><li class="navelem"><a class="el" href="awd_specs.html">AWD 3.0 Specifications</a></li>
    <li class="footer">Generated on Mon Feb 2 2015 18:04:26 for cpp-libawd by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.8 </li>
  </ul>
</div>
</body>
</html>
